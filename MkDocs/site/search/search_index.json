{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home This documentation website composes the final hand-in for the course Software Development for Technical Applications (VSMN20) at Lund University. This page contains a brief theoretical introduction to groundwater flow, details on the program structure, manuals for both the application and the module. Each part has its own page, which can be reached by using the top navigation tab. A git repository containing the latest program version is available here . Acknowledgements The website is built using MkDocs with a theme and additional functionality from Material for MkDocs . For the source code documentation, the plugin mkdocstrings was used. The application UI was inspired by multiple QtDesigner tutorials made by Wanderson on YouTube. Python packages This program was written in a default Anaconda3 environment, with the addition a few of packages. I recommend that the conda environment is updated, since I myself experienced some problems. Further that that pip is used to verify the installment of the neccecary packages that are not included in Anaconda3: conda update --all pip install gmsh calfem-python If one want to experiment with MkDocs do so by installing the packages and host the website locally with: pip install mkdocs mkdocs-material mkdocstrings ...\\MkDocs> mkdocs serve","title":"Home"},{"location":"#home","text":"This documentation website composes the final hand-in for the course Software Development for Technical Applications (VSMN20) at Lund University. This page contains a brief theoretical introduction to groundwater flow, details on the program structure, manuals for both the application and the module. Each part has its own page, which can be reached by using the top navigation tab. A git repository containing the latest program version is available here .","title":"Home"},{"location":"#acknowledgements","text":"The website is built using MkDocs with a theme and additional functionality from Material for MkDocs . For the source code documentation, the plugin mkdocstrings was used. The application UI was inspired by multiple QtDesigner tutorials made by Wanderson on YouTube. Python packages This program was written in a default Anaconda3 environment, with the addition a few of packages. I recommend that the conda environment is updated, since I myself experienced some problems. Further that that pip is used to verify the installment of the neccecary packages that are not included in Anaconda3: conda update --all pip install gmsh calfem-python If one want to experiment with MkDocs do so by installing the packages and host the website locally with: pip install mkdocs mkdocs-material mkdocstrings ...\\MkDocs> mkdocs serve","title":"Acknowledgements"},{"location":"AppManual/","text":"Application Manual Warning for resolutions other than FullHD This page was created on a 1080p monitor, and due to the picture alignment I suspect that the scaling for other resolution will be less than good. Sorry, but not much one can do about it. Interface The final application interface is shown below. It consists of different sections which have thoughtfully been placed together to provide an intuitive and easy to use application. How to use these sections will be described, but first some short tips. If unsure about the model parameters, utilize the reference geometry in the top-middle frame. See which model is being worked on in the bottom left corner, if empty this suggest that the current model has not been saved. Resize the window by grabbing the bottom-right corner. Move the window by grabbing any non-interactive widget. Application interface Input The input section is where the user enters its dimensional parameters, dam pressure and permeability by clicking within the field and typing. These are all used for both the regular and parameter computations. All values should be positive, w > t and h > d has to be fulfilled for the model to be valid. When performing a parameter study the requirements is expanded to, h > d_end > d for a study of depth and w > t_end > t for a study of thickness. Utility The utility section mainly concerns calculations. Determine the mesh element size with the sliding bar, smaller values correlate to a finer mesh and longer computation. If a regular study is to be done press the Execute button, or use the keyboard shortcut Ctrl + Enter . When performing a parameter study, choose first the variable to study with the radio button. Then enter the end and amount of steps, consider the computation time and reduce either steps or increase element mesh size. To execute the parameter study click the Parameter Study button or the shortcut Ctrl + Alt + Enter . To clear the canvas use the Clear Canvas button or the shortcut Ctrl + C . Plotting All buttons for plotting are found here, these can be repeatedly used to switch between all outputs. The only restriction is that a regular computation has to been made, or for the case of Maximum Flux a parameter study. Use the built in functionality of matplotlibs to zoom in on interesting regions, drag the geometry around or save the figures. File The file functionality has been designed to be easy to use. All filedialogs begin at the project folder, from which it is easy to access the predefined data folder. This folder contain two JSON files, both are safe to open even if one is from an older version. There is no need to worry about VTK-files cluttering the project folder, all VTK files are saved to a dedicated VTK folder which is created if it does not already exist. Be carful of using New since there is no warning of unsaved data, neither here or for any of the other method. Take note of the standardized keyboard shortcuts, they might come in handy. Examples Examples from a parameter study for the default geometry are available within the the Examples folder in the project directory. Within this folder, a total of four animations are available. They visualize piezometric head and effective flux for studies of both dam thickness and width. An text file is also available with the chosen parameters, the input data. There is two JSON files available in the data folder. One is newly saved model from the latest application version (7), this provides an alternative starting point for calculations compared to that of the default values. The other file is from an older application version (4) and can be used to verify that older models will not throw errors, but will inform the user of this fact.","title":"Application Manual"},{"location":"AppManual/#application-manual","text":"Warning for resolutions other than FullHD This page was created on a 1080p monitor, and due to the picture alignment I suspect that the scaling for other resolution will be less than good. Sorry, but not much one can do about it.","title":"Application Manual"},{"location":"AppManual/#interface","text":"The final application interface is shown below. It consists of different sections which have thoughtfully been placed together to provide an intuitive and easy to use application. How to use these sections will be described, but first some short tips. If unsure about the model parameters, utilize the reference geometry in the top-middle frame. See which model is being worked on in the bottom left corner, if empty this suggest that the current model has not been saved. Resize the window by grabbing the bottom-right corner. Move the window by grabbing any non-interactive widget. Application interface","title":"Interface"},{"location":"AppManual/#input","text":"The input section is where the user enters its dimensional parameters, dam pressure and permeability by clicking within the field and typing. These are all used for both the regular and parameter computations. All values should be positive, w > t and h > d has to be fulfilled for the model to be valid. When performing a parameter study the requirements is expanded to, h > d_end > d for a study of depth and w > t_end > t for a study of thickness.","title":"Input"},{"location":"AppManual/#utility","text":"The utility section mainly concerns calculations. Determine the mesh element size with the sliding bar, smaller values correlate to a finer mesh and longer computation. If a regular study is to be done press the Execute button, or use the keyboard shortcut Ctrl + Enter . When performing a parameter study, choose first the variable to study with the radio button. Then enter the end and amount of steps, consider the computation time and reduce either steps or increase element mesh size. To execute the parameter study click the Parameter Study button or the shortcut Ctrl + Alt + Enter . To clear the canvas use the Clear Canvas button or the shortcut Ctrl + C .","title":"Utility"},{"location":"AppManual/#plotting","text":"All buttons for plotting are found here, these can be repeatedly used to switch between all outputs. The only restriction is that a regular computation has to been made, or for the case of Maximum Flux a parameter study. Use the built in functionality of matplotlibs to zoom in on interesting regions, drag the geometry around or save the figures.","title":"Plotting"},{"location":"AppManual/#file","text":"The file functionality has been designed to be easy to use. All filedialogs begin at the project folder, from which it is easy to access the predefined data folder. This folder contain two JSON files, both are safe to open even if one is from an older version. There is no need to worry about VTK-files cluttering the project folder, all VTK files are saved to a dedicated VTK folder which is created if it does not already exist. Be carful of using New since there is no warning of unsaved data, neither here or for any of the other method. Take note of the standardized keyboard shortcuts, they might come in handy.","title":"File"},{"location":"AppManual/#examples","text":"Examples from a parameter study for the default geometry are available within the the Examples folder in the project directory. Within this folder, a total of four animations are available. They visualize piezometric head and effective flux for studies of both dam thickness and width. An text file is also available with the chosen parameters, the input data. There is two JSON files available in the data folder. One is newly saved model from the latest application version (7), this provides an alternative starting point for calculations compared to that of the default values. The other file is from an older application version (4) and can be used to verify that older models will not throw errors, but will inform the user of this fact.","title":"Examples"},{"location":"Developement/","text":"Development This page is dedicated to discuss and present how the program was built. It discusses the problems that was faced in development and also the expansions made outside the required functionality. All code is found under the Code Reference tab, all examples are found under the manual tabs. Structure The development of this project was made through several iterative assignments, each building on the previous iteration. From the beginning the flowmodel module has been separated from the runnable scripts or applications. This is done in order to make it usable in general applications and not only the one application. At times this has complicated implementation of additional features, but it is worth the effort to keep the flowmodel module independent. The module has been used several times with different scripts and applications, but in this final assignment it was used by a purpose built application by the name GWapp. This application is used by the end user, to interact with the module functionality and to visualize its results. Further, a single class module was used as a stopwatch for debugging purposes. All results can be saved and loaded with JSON files. How all these components relate to each other, was for the final version visualized with the flowchart below. Flowchart of project structure Flowmodel Module As stated before, the flowmodel was designed to be an independent module. It was to contain classes and functions to perform finite element analysis on a groundwater flow of a simplified dam. While containing core features required by the assignments, it has been expanded slightly to get additional optional functionality that are utilized by the application. InputData The InputData has gotten an additional attribute el_size_factor so that the maximal element size can be modified. This allows for the user to choose the accuracy and computation time, which is especially important when performing a parameter study. Additionally instead of using two attributes to know if which parameter to study, this program only uses one dStudy to check if d should be studied or not. Exception handling was implemented for the file functionality methods to avoid common crashes. This was then connected to a return boolean which can be utilized to avoid running the statements that follow the function-call or to present error messages within the application. The simplified dam structure geometry is constructed by the geometry method. This geometry only makes physical sense for a certain set of values where all parameters are larger than zero, w > t and h > d . Hence, the method validModel was implemented to check these requirements. Since some physical limitations are also valid for the parameter study, an equivalent method validParam was implemented to check if h > d_end > d for a study of depth and w > t_end > t for a study of thickness. Warning for memory limit While the two methods validModel and validParam checks for logical errors within the input data, they are not foolproof. Depending on the machine there is a limitation on memory usage which can be violated when one chooses very large widths w and heights d . A general guideline is to not overstep a width of 100 m and height of 50 m when using mesh element size of 0.5. OutputData The OutputData class has a single functionality of storing different calculated values. While the application does not use all attributes, they are kept as another program might. Two additional attributes has been added to allow plotting of maximum effective flux for a parameter study, these are range and max_flux . Solver Two new attributes were added to the Solver class, both has default values if nothing is declared in the constructor. The first attribute basepath is a base path used for export of VTK files. The second attribute pg is a progressbar which can be passed from the application in order have a semi-accurate progressbar. To only call progressbar methods when an attribute is defined, truncated if-statement is used. These use Python feature that non-empty/zero objects return True in combinations with logic operators. # These are equivalent argument and function () if argument : function () The execute method uses a typical finite element method scheme which is defined by the flowchart beneath. Most steps are performed with predefined methods contained within CALFEM for Python. This method is then used within the parameter study loop in the executeParamStudy method. Flowchart of finite element solver Report With the Report class the purpose is to present input and output data in a clear way from the attributes of InputData and OutputData . While the input data consists of mainly scalars, the output data contains large float type vectors and matrices which requires significant formatting. The results are displayed in tables for each node and for each element. As these tables can become massive, the scalar values are displayed first to be more easily available. The scalar output values are number of nodes, number of elements and the maximal effective flux. Visualization To visualize output data, the class Visualization is used. This class creates figures and stores them as attributes. Originally all plots were plotted within separate windows, which is still the case for showAll which presents all figures. However, I wished to show figures within the application, a more difficult task than first thought. Since figures could not be simply returned, due to how matplotlib and CALFEM Visualisation handles figures. With research a promising backend PyQt class FigureCanvasQTAgg of matplotlib was found. Its objects are PyQt5 compatible and can render figures from matplotlib and by extension CALFEM Visualisation. Another highly useful method is figure_widget from CALFEM Visualisation, which takes a figure argument and returns a FigureCanvasQTAgg object. The FigureCanvasQTAgg objects are also saved as attributes, hence also closed in closeAll . To keep the individual plotting functions independent of this new extension, the keyword argument show was added. When it has its default value of true, the figures are shown in their own windows, when it is assigned false it suppresses the figures from showing and returns a FigureCanvasQTAgg object. GWapp Application The application is meant to connect the user with the flowmodel module, with an easy to use graphical interface. In this case we used the Qt framework to implement a graphical interface that could be used on any platform. MainWindow The MainWindow class contains the bulk of the application with the UI, functions and all connections between them. Most functions are have little to no content and only calls on methods from the flowmodel module. The UI is designed from the ground up and should contain everything a user might need, the user should not have to use the console apart from debugging. Design To ease the design process, the Qt Designer program is used which has real time previews and drag and drop features. However, not all features are available within the program and some tinkering had to be done with code using PyQt5. The first iterations of the interface were disorganized and used layouts in a way that would bad for scaling. Through iterative development a system of nested layouts was used to achieve predictable behavior during scaling. Through experimentation with stylesheets, I put my novice CSS knowledge to use in changing colors, margins and borders. With several different iterations of the interface and a better familiarity with Qt Designer, a new interface was designed. This time a more coherent color palette was used, seen below, alongside color-matched free to use icons from flaticon . Primary color palette Although my artistic merits are close to none, the result were much better. Nevertheless, both the menubar and the frame could not be modified to match the new design within Qt Designer. A custom topbar was designed with window buttons (minimize, maximize/restore and exit) and menu buttons (File and Utility), and the frame was removed with PyQt5 within the constructor. Since Qt Designer is missing the ability to ad QMenus, these had to be constructed with PyQt5. This was done by defining a shared stylesheet, creating a QMenu with all wanted actions and then attaching the menu to the menu buttons. Each action were paired with both an icon and a keyboard shortcut. Removing the frame there were no longer any grabbable surface to move or resize the window with. The solution for this was more complicated than expected and was inspired by a stack overflow answer by user musicamante. After modification, all non-intractable (not Button, PlainTextEdit, Slider) became grabbable to move the window. The inner workings are illustrated with the flowchart below. flowchart LR A([MB clicked]) --> B{LMB?} B -- Yes --> C[Set offset] C -. float .-> X[(Offset)] D([Mouse moved]) --> E{LMB held?<br>Windowed?<br>Offset!=None?} X o--o E E -- All yes --> F[Move relative offset] G([MB Released]) -. None .-> X Still no borders were available to grip in order to resize the window. To remedy this, a QFrame was added to the bottom right corner to which QSizeGrip were attached which allowed for resizing when grabbed. For extra clarification, an icon were added and when hovered over, the cursor is changed and a tooltip appears. While at it, the program icon was changed from the default Python executable to a custom made logo to represent the geometry. In order for the logo to be shown in windows, the application had to be assigned an unique application ID. Waring for Mac and Linux This program has been developed on machines using Windows, hence I have no idea if the program will run as intended on Linux or Mac. Since assigning an unique application ID is specific to Windows, the following line can be removed from MainWindow.__init__ if the application is run in other platforms. ctypes . windll . shell32 . SetCurrentProcessExplicitAppUserModelID ( \"GWapp\" ) Functionality Within the constructor all intractable elements of the UI has to be connected to methods within the class. A lot of methods are created to handle all possible actions of the UI, although some short actions could be written with lambda functions. The methods are divided into a couple of categories: UI methods is consist of the maximize method which works restores or maximizes the UI while changing some elements. It is accompanied by exit which prompts the user before the program is terminated and all progress is lost. Utility methods correlates to the methods used when performing a simulation or parameter study. The methods onActionExecute and onExecuteParamStudy both utilizes the validation methods of InputData before calculations. If the model is invalid, the user is prompted with the requirements and no calculations are made. Input and output contains several updating and file-functionality methods. To begin with, the updateControls method puts InputData attributes into the controls while updateModel reads data from the controls and puts them into InputData attributes. For the latter, simple exception handling was used to catch when incorrect types are read. With updateEnd only the currently displayed end value is read and put into the corresponding InputData attribute. Lastly updateName extracts the model name from the path attribute and updates the name within the UI. Report and Figures A QTabWidget is used to utilize the same space for the report and figures. The report is changed with calls of setPlainText() on the UI QPlainTextEdit attribute and its tab is always opened after new calculations. For figures, an empty FigureCanvasQTAgg attribute was initiated and manual placed into the opposite tab. In order to change the figure the method updateCanvas was implemented. This method uses the returned FigureCanvasQTAgg from the visualization methods to replace the previous canvas with replaceWidget . The method is accompanied by clearCanvas , which is connected to the clear canvas button. An addition to all plotting methods is the usage of message which prompts the user that relevant result has not been calculated for plotting attempts. Progress When the program was finished there was still some things that were printed to the console, which provided the user with valuable information. One of these were all status printouts of the Solver class. To make these available to the application an object had to be passed to the solver instance. At first this was done with the QPlainTextEdit meant for the report. While it was sufficient, it was clunky and not visually pleasing. With the more familiarity with Qt from the design of the MainWindow , an initial design was made as an round window with percentage and current step on display. Originally the background was supposed to indicate the percentage by recoloring the background clockwise. This was done by changing the stylesheet, but proved unreliable with randomly occurring crashes. The design was then changed slightly and a fading display of previous steps were added. A new class Progress that handles the progressbar inherits from QMainWindow and has two methods, one to update segment name and percentage, a second to close and reset the window. An object of this type is passed to the a Solver object which can set progress of regular calculations and parameter studies. Study of computation time The percentages of each step in the solver had to be set manually and it was quickly noted that the percentages varied as parameters were changed. In an effort to identify governing factors, an faulty assumption was made that a the relation could be derived by experimenting with parameters and graphing the results. For this purpose the SegmentTimer was implemented to act as a stopwatch. After gathering a data set and trying multiple methods to extract any relations, it was realized that it was an impossible task. The percentages was instead chosen to match the average of several runs with the default parameters. SolverThread No modifications were made to the suggested SolverThread class used to create threads for the execute and executeParamStudy methods of the Solver class. Validation In the earliest iteration of the program, the solver had to be validated by a similar calculation made with Matlab. Using a simple four element geometry with prescribed parameters, the results became identical apart from the amount of float points that was printed. These results are presented in the table beneath. Input Data Python Matlab Thickness (t) [m]: 1 1 Permeability matrix (perm) [m/day]: [[50. 0.] [ 0. 50.]] 50 0 0 50 Loads (loads) [node, m^2/day]: [[6, -400.0]] 6 -400 Boundary conditions (bcs) [node, m]: [[2, 60.0], [4, 60.0]] 2 60 4 60 Nodal coordinates (coord) [m]: [[ 0. 0.] [ 0. 600.] [ 600. 0.] [ 600. 600.] [1200. 0.] [1200. 600.]] 0 0 0 600 600 0 600 600 1200 0 1200 600 Degrees of freedom (dof) [idx]: [[1] [2] [3] [4] [5] [6]] 1 2 3 4 5 6 Topology (edof) [node, node, node]: [[1 4 2] [1 3 4] [3 6 4] [3 5 6]] 1 1 4 2 2 1 3 4 3 3 6 4 4 3 5 6 Output Data Nodal piezometric head (a) [m]: [[59.05882353] [60. ] [58.11764706] [60. ] [53.41176471] [48.70588235]] 59.0588 60.0000 58.1176 60.0000 53.4118 48.7059 Nodal reaction flux (r) [m^2/day]: [[ 0.00000000e+00] [ 2.35294118e+01] [ 0.00000000e+00] [ 3.76470588e+02] [-2.27373675e-13] [ 2.27373675e-13]] 0.0000 23.5294 0.0000 376.4706 -0.0000 -0.0000 Elemental piezometric head (ed) [m]: [[59.05882353 60. 60. ] [59.05882353 58.11764706 60. ] [58.11764706 48.70588235 60. ] [58.11764706 53.41176471 48.70588235]] 59.0588 60.0000 60.0000 59.0588 58.1176 60.0000 58.1176 48.7059 60.0000 58.1176 53.4118 48.7059 Elemental volume flux (qs) [m^2/day]: [[ 0. -0.07843137] [ 0.07843137 -0.15686275] [ 0.94117647 -0.15686275] [ 0.39215686 0.39215686]] 0 -0.0784 0.0784 -0.1569 0.9412 -0.1569 0.3922 0.3922 Elemental hydraulic gradient (qt) [m]: [[ 0. 0.00156863] [-0.00156863 0.00313725] [-0.01882353 0.00313725] [-0.00784314 -0.00784314]] 0 0.0016 -0.0016 0.0031 -0.0188 0.0031 -0.0078 -0.0078","title":"Developement"},{"location":"Developement/#development","text":"This page is dedicated to discuss and present how the program was built. It discusses the problems that was faced in development and also the expansions made outside the required functionality. All code is found under the Code Reference tab, all examples are found under the manual tabs.","title":"Development"},{"location":"Developement/#structure","text":"The development of this project was made through several iterative assignments, each building on the previous iteration. From the beginning the flowmodel module has been separated from the runnable scripts or applications. This is done in order to make it usable in general applications and not only the one application. At times this has complicated implementation of additional features, but it is worth the effort to keep the flowmodel module independent. The module has been used several times with different scripts and applications, but in this final assignment it was used by a purpose built application by the name GWapp. This application is used by the end user, to interact with the module functionality and to visualize its results. Further, a single class module was used as a stopwatch for debugging purposes. All results can be saved and loaded with JSON files. How all these components relate to each other, was for the final version visualized with the flowchart below. Flowchart of project structure","title":"Structure"},{"location":"Developement/#flowmodel-module","text":"As stated before, the flowmodel was designed to be an independent module. It was to contain classes and functions to perform finite element analysis on a groundwater flow of a simplified dam. While containing core features required by the assignments, it has been expanded slightly to get additional optional functionality that are utilized by the application.","title":"Flowmodel Module"},{"location":"Developement/#inputdata","text":"The InputData has gotten an additional attribute el_size_factor so that the maximal element size can be modified. This allows for the user to choose the accuracy and computation time, which is especially important when performing a parameter study. Additionally instead of using two attributes to know if which parameter to study, this program only uses one dStudy to check if d should be studied or not. Exception handling was implemented for the file functionality methods to avoid common crashes. This was then connected to a return boolean which can be utilized to avoid running the statements that follow the function-call or to present error messages within the application. The simplified dam structure geometry is constructed by the geometry method. This geometry only makes physical sense for a certain set of values where all parameters are larger than zero, w > t and h > d . Hence, the method validModel was implemented to check these requirements. Since some physical limitations are also valid for the parameter study, an equivalent method validParam was implemented to check if h > d_end > d for a study of depth and w > t_end > t for a study of thickness. Warning for memory limit While the two methods validModel and validParam checks for logical errors within the input data, they are not foolproof. Depending on the machine there is a limitation on memory usage which can be violated when one chooses very large widths w and heights d . A general guideline is to not overstep a width of 100 m and height of 50 m when using mesh element size of 0.5.","title":"InputData"},{"location":"Developement/#outputdata","text":"The OutputData class has a single functionality of storing different calculated values. While the application does not use all attributes, they are kept as another program might. Two additional attributes has been added to allow plotting of maximum effective flux for a parameter study, these are range and max_flux .","title":"OutputData"},{"location":"Developement/#solver","text":"Two new attributes were added to the Solver class, both has default values if nothing is declared in the constructor. The first attribute basepath is a base path used for export of VTK files. The second attribute pg is a progressbar which can be passed from the application in order have a semi-accurate progressbar. To only call progressbar methods when an attribute is defined, truncated if-statement is used. These use Python feature that non-empty/zero objects return True in combinations with logic operators. # These are equivalent argument and function () if argument : function () The execute method uses a typical finite element method scheme which is defined by the flowchart beneath. Most steps are performed with predefined methods contained within CALFEM for Python. This method is then used within the parameter study loop in the executeParamStudy method. Flowchart of finite element solver","title":"Solver"},{"location":"Developement/#report","text":"With the Report class the purpose is to present input and output data in a clear way from the attributes of InputData and OutputData . While the input data consists of mainly scalars, the output data contains large float type vectors and matrices which requires significant formatting. The results are displayed in tables for each node and for each element. As these tables can become massive, the scalar values are displayed first to be more easily available. The scalar output values are number of nodes, number of elements and the maximal effective flux.","title":"Report"},{"location":"Developement/#visualization","text":"To visualize output data, the class Visualization is used. This class creates figures and stores them as attributes. Originally all plots were plotted within separate windows, which is still the case for showAll which presents all figures. However, I wished to show figures within the application, a more difficult task than first thought. Since figures could not be simply returned, due to how matplotlib and CALFEM Visualisation handles figures. With research a promising backend PyQt class FigureCanvasQTAgg of matplotlib was found. Its objects are PyQt5 compatible and can render figures from matplotlib and by extension CALFEM Visualisation. Another highly useful method is figure_widget from CALFEM Visualisation, which takes a figure argument and returns a FigureCanvasQTAgg object. The FigureCanvasQTAgg objects are also saved as attributes, hence also closed in closeAll . To keep the individual plotting functions independent of this new extension, the keyword argument show was added. When it has its default value of true, the figures are shown in their own windows, when it is assigned false it suppresses the figures from showing and returns a FigureCanvasQTAgg object.","title":"Visualization"},{"location":"Developement/#gwapp-application","text":"The application is meant to connect the user with the flowmodel module, with an easy to use graphical interface. In this case we used the Qt framework to implement a graphical interface that could be used on any platform.","title":"GWapp Application"},{"location":"Developement/#mainwindow","text":"The MainWindow class contains the bulk of the application with the UI, functions and all connections between them. Most functions are have little to no content and only calls on methods from the flowmodel module. The UI is designed from the ground up and should contain everything a user might need, the user should not have to use the console apart from debugging.","title":"MainWindow"},{"location":"Developement/#design","text":"To ease the design process, the Qt Designer program is used which has real time previews and drag and drop features. However, not all features are available within the program and some tinkering had to be done with code using PyQt5. The first iterations of the interface were disorganized and used layouts in a way that would bad for scaling. Through iterative development a system of nested layouts was used to achieve predictable behavior during scaling. Through experimentation with stylesheets, I put my novice CSS knowledge to use in changing colors, margins and borders. With several different iterations of the interface and a better familiarity with Qt Designer, a new interface was designed. This time a more coherent color palette was used, seen below, alongside color-matched free to use icons from flaticon . Primary color palette Although my artistic merits are close to none, the result were much better. Nevertheless, both the menubar and the frame could not be modified to match the new design within Qt Designer. A custom topbar was designed with window buttons (minimize, maximize/restore and exit) and menu buttons (File and Utility), and the frame was removed with PyQt5 within the constructor. Since Qt Designer is missing the ability to ad QMenus, these had to be constructed with PyQt5. This was done by defining a shared stylesheet, creating a QMenu with all wanted actions and then attaching the menu to the menu buttons. Each action were paired with both an icon and a keyboard shortcut. Removing the frame there were no longer any grabbable surface to move or resize the window with. The solution for this was more complicated than expected and was inspired by a stack overflow answer by user musicamante. After modification, all non-intractable (not Button, PlainTextEdit, Slider) became grabbable to move the window. The inner workings are illustrated with the flowchart below. flowchart LR A([MB clicked]) --> B{LMB?} B -- Yes --> C[Set offset] C -. float .-> X[(Offset)] D([Mouse moved]) --> E{LMB held?<br>Windowed?<br>Offset!=None?} X o--o E E -- All yes --> F[Move relative offset] G([MB Released]) -. None .-> X Still no borders were available to grip in order to resize the window. To remedy this, a QFrame was added to the bottom right corner to which QSizeGrip were attached which allowed for resizing when grabbed. For extra clarification, an icon were added and when hovered over, the cursor is changed and a tooltip appears. While at it, the program icon was changed from the default Python executable to a custom made logo to represent the geometry. In order for the logo to be shown in windows, the application had to be assigned an unique application ID. Waring for Mac and Linux This program has been developed on machines using Windows, hence I have no idea if the program will run as intended on Linux or Mac. Since assigning an unique application ID is specific to Windows, the following line can be removed from MainWindow.__init__ if the application is run in other platforms. ctypes . windll . shell32 . SetCurrentProcessExplicitAppUserModelID ( \"GWapp\" )","title":"Design"},{"location":"Developement/#functionality","text":"Within the constructor all intractable elements of the UI has to be connected to methods within the class. A lot of methods are created to handle all possible actions of the UI, although some short actions could be written with lambda functions. The methods are divided into a couple of categories: UI methods is consist of the maximize method which works restores or maximizes the UI while changing some elements. It is accompanied by exit which prompts the user before the program is terminated and all progress is lost. Utility methods correlates to the methods used when performing a simulation or parameter study. The methods onActionExecute and onExecuteParamStudy both utilizes the validation methods of InputData before calculations. If the model is invalid, the user is prompted with the requirements and no calculations are made. Input and output contains several updating and file-functionality methods. To begin with, the updateControls method puts InputData attributes into the controls while updateModel reads data from the controls and puts them into InputData attributes. For the latter, simple exception handling was used to catch when incorrect types are read. With updateEnd only the currently displayed end value is read and put into the corresponding InputData attribute. Lastly updateName extracts the model name from the path attribute and updates the name within the UI.","title":"Functionality"},{"location":"Developement/#report-and-figures","text":"A QTabWidget is used to utilize the same space for the report and figures. The report is changed with calls of setPlainText() on the UI QPlainTextEdit attribute and its tab is always opened after new calculations. For figures, an empty FigureCanvasQTAgg attribute was initiated and manual placed into the opposite tab. In order to change the figure the method updateCanvas was implemented. This method uses the returned FigureCanvasQTAgg from the visualization methods to replace the previous canvas with replaceWidget . The method is accompanied by clearCanvas , which is connected to the clear canvas button. An addition to all plotting methods is the usage of message which prompts the user that relevant result has not been calculated for plotting attempts.","title":"Report and Figures"},{"location":"Developement/#progress","text":"When the program was finished there was still some things that were printed to the console, which provided the user with valuable information. One of these were all status printouts of the Solver class. To make these available to the application an object had to be passed to the solver instance. At first this was done with the QPlainTextEdit meant for the report. While it was sufficient, it was clunky and not visually pleasing. With the more familiarity with Qt from the design of the MainWindow , an initial design was made as an round window with percentage and current step on display. Originally the background was supposed to indicate the percentage by recoloring the background clockwise. This was done by changing the stylesheet, but proved unreliable with randomly occurring crashes. The design was then changed slightly and a fading display of previous steps were added. A new class Progress that handles the progressbar inherits from QMainWindow and has two methods, one to update segment name and percentage, a second to close and reset the window. An object of this type is passed to the a Solver object which can set progress of regular calculations and parameter studies.","title":"Progress"},{"location":"Developement/#study-of-computation-time","text":"The percentages of each step in the solver had to be set manually and it was quickly noted that the percentages varied as parameters were changed. In an effort to identify governing factors, an faulty assumption was made that a the relation could be derived by experimenting with parameters and graphing the results. For this purpose the SegmentTimer was implemented to act as a stopwatch. After gathering a data set and trying multiple methods to extract any relations, it was realized that it was an impossible task. The percentages was instead chosen to match the average of several runs with the default parameters.","title":"Study of computation time"},{"location":"Developement/#solverthread","text":"No modifications were made to the suggested SolverThread class used to create threads for the execute and executeParamStudy methods of the Solver class.","title":"SolverThread"},{"location":"Developement/#validation","text":"In the earliest iteration of the program, the solver had to be validated by a similar calculation made with Matlab. Using a simple four element geometry with prescribed parameters, the results became identical apart from the amount of float points that was printed. These results are presented in the table beneath. Input Data Python Matlab Thickness (t) [m]: 1 1 Permeability matrix (perm) [m/day]: [[50. 0.] [ 0. 50.]] 50 0 0 50 Loads (loads) [node, m^2/day]: [[6, -400.0]] 6 -400 Boundary conditions (bcs) [node, m]: [[2, 60.0], [4, 60.0]] 2 60 4 60 Nodal coordinates (coord) [m]: [[ 0. 0.] [ 0. 600.] [ 600. 0.] [ 600. 600.] [1200. 0.] [1200. 600.]] 0 0 0 600 600 0 600 600 1200 0 1200 600 Degrees of freedom (dof) [idx]: [[1] [2] [3] [4] [5] [6]] 1 2 3 4 5 6 Topology (edof) [node, node, node]: [[1 4 2] [1 3 4] [3 6 4] [3 5 6]] 1 1 4 2 2 1 3 4 3 3 6 4 4 3 5 6 Output Data Nodal piezometric head (a) [m]: [[59.05882353] [60. ] [58.11764706] [60. ] [53.41176471] [48.70588235]] 59.0588 60.0000 58.1176 60.0000 53.4118 48.7059 Nodal reaction flux (r) [m^2/day]: [[ 0.00000000e+00] [ 2.35294118e+01] [ 0.00000000e+00] [ 3.76470588e+02] [-2.27373675e-13] [ 2.27373675e-13]] 0.0000 23.5294 0.0000 376.4706 -0.0000 -0.0000 Elemental piezometric head (ed) [m]: [[59.05882353 60. 60. ] [59.05882353 58.11764706 60. ] [58.11764706 48.70588235 60. ] [58.11764706 53.41176471 48.70588235]] 59.0588 60.0000 60.0000 59.0588 58.1176 60.0000 58.1176 48.7059 60.0000 58.1176 53.4118 48.7059 Elemental volume flux (qs) [m^2/day]: [[ 0. -0.07843137] [ 0.07843137 -0.15686275] [ 0.94117647 -0.15686275] [ 0.39215686 0.39215686]] 0 -0.0784 0.0784 -0.1569 0.9412 -0.1569 0.3922 0.3922 Elemental hydraulic gradient (qt) [m]: [[ 0. 0.00156863] [-0.00156863 0.00313725] [-0.01882353 0.00313725] [-0.00784314 -0.00784314]] 0 0.0016 -0.0016 0.0031 -0.0188 0.0031 -0.0078 -0.0078","title":"Validation"},{"location":"GWapp/","text":"Code Reference GWapp.py Groundwater flow app This program contains three classes and a main-script for launching an app off groundwater flow. Through the use of flowmodel.py results can be ploted for individual executions. Parameter studies are possible, with results exported to VTK-files which can be visualized within Paraview. The app utilizes pyqt5 with the design mainly being made whithin Qt Designer. MainWindow ( QMainWindow ) Class to create app Attributes: Name Type Description path str String of current model/file path dir str String of current directory name app QApplication pg Progress Object for progress window visualization Visualization Object for plotting output data input_data InputData Object containing input data output_data OutputData Object containing output data ui QWidget Object containing all UI elements canvas FigureCanvasQTAgg Canvas to draw figures on offset - Temporary variable for movement of window windowed bool Flag if app is windowed or not Source code in src\\gwapp.py class MainWindow ( QMainWindow ): \"\"\"Class to create app Attributes: path (str): String of current model/file path dir (str): String of current directory name app (QApplication): pg (Progress): Object for progress window visualization (Visualization): Object for plotting output data input_data (InputData): Object containing input data output_data (OutputData): Object containing output data ui (QWidget): Object containing all UI elements canvas (FigureCanvasQTAgg): Canvas to draw figures on offset (-): Temporary variable for movement of window windowed (bool): Flag if app is windowed or not \"\"\" def __init__ ( self ): super ( QMainWindow , self ) . __init__ () # File Attributes self . path = \"\" self . dir = os . path . dirname ( __file__ ) + \" \\\\ \" # Window attributes self . app = app self . pg = Progress ( self . dir ) self . visualization = None self . input_data = fm . InputData () self . output_data = fm . OutputData () self . ui = loadUi ( self . dir + \"mainwindow.ui\" , self ) self . canvas = Canvas () # Flag attributes self . offset = None self . windowed = True # Create directory for VTK exports vtkdir = self . dir + \" \\\\ VTK \\\\ \" not os . path . isdir ( vtkdir ) and mkdir ( vtkdir ) # Above is a truncated if statement, \"arg and func\" = \"if arg: func\". # Window buttons self . exitButton . clicked . connect ( self . exit ) self . maxiButton . clicked . connect ( self . maximize ) self . miniButton . clicked . connect ( lambda : self . showMinimized ()) # Ploting buttons self . showGeoButton . clicked . connect ( self . showGeo ) self . showMeshButton . clicked . connect ( self . showMesh ) self . showPizeoButton . clicked . connect ( self . showPizeo ) self . showEffButton . clicked . connect ( self . showEff ) self . showParamButton . clicked . connect ( self . showParam ) # Utility buttons self . executeButton . clicked . connect ( self . onActionExecute ) self . clearCanvasButton . clicked . connect ( self . clearCanvas ) # Mesh size slider self . meshSlider . valueChanged . connect ( lambda : self . meshLabel . setText ( str ( self . meshSlider . value () / 10 ))) # Parameter study interface self . dRadio . toggled . connect ( self . updateEnd ) self . paraButton . clicked . connect ( self . onExecuteParamStudy ) # Visualization canvas self . canvas . figure . set_facecolor ( \"#F1FAEE\" ) self . layout = QVBoxLayout () self . layout . addWidget ( self . canvas ) self . figureFrame . setLayout ( self . layout ) # Sizegrip to resize window, southwest corner self . sizegrip = QSizeGrip ( self . cornerFrame ) self . sizegrip . setToolTip ( \"Grip to move\" ) # Remove default window borders self . setWindowFlag ( Qt . FramelessWindowHint ) self . setAttribute ( Qt . WA_TranslucentBackground ) # Set program (taskbar) icon, gives Windows an unique application ID self . setWindowIcon ( QIcon ( self . dir + r \"Assets\\icon.png\" )) ctypes . windll . shell32 . SetCurrentProcessExplicitAppUserModelID ( \"GWapp\" ) # Menubar menus stylesheet = \"\"\" QMenu { color: rgb(241, 250, 238); background-color: rgb(15, 27, 44); border: 5px solid rgb(15, 27, 44); } QMenu::item:selected { background-color: rgb(29, 53, 87); }\"\"\" # File menu file = QMenu () file . setStyleSheet ( stylesheet ) file . addAction ( QIcon ( self . dir + r \"Assets\\page.png\" ), \"New\" , self . onActionNew , QKeySequence ( Qt . CTRL + Qt . Key_N )) file . addAction ( QIcon ( self . dir + r \"Assets\\open.png\" ), \"Open\" , self . onActionOpen , QKeySequence ( Qt . CTRL + Qt . Key_O )) file . addSeparator () file . addAction ( QIcon ( self . dir + r \"Assets\\save.png\" ), \"Save\" , self . onActionSave , QKeySequence ( Qt . CTRL + Qt . Key_S )) file . addAction ( QIcon ( self . dir + r \"Assets\\saveas.png\" ), \"SaveAs\" , self . onActionSaveAs , QKeySequence ( Qt . CTRL + Qt . ALT + Qt . Key_S )) file . addSeparator () file . addAction ( QIcon ( self . dir + r \"Assets\\cross.png\" ), \"Exit\" , self . exit , QKeySequence ( Qt . CTRL + Qt . Key_E )) self . fileButton . setMenu ( file ) # Utility menu util = QMenu () util . setStyleSheet ( stylesheet ) util . addAction ( QIcon ( self . dir + r \"Assets\\play.png\" ), \"Execute\" , self . onActionExecute , QKeySequence ( Qt . CTRL + Qt . Key_Return )) util . addAction ( QIcon ( self . dir + r \"Assets\\para.png\" ), \"Parameter study\" , self . onExecuteParamStudy , QKeySequence ( Qt . CTRL + Qt . ALT + Qt . Key_Return )) util . addSeparator () util . addAction ( QIcon ( self . dir + r \"Assets\\clear.png\" ), \"Clear Canvas\" , self . clearCanvas , QKeySequence ( Qt . CTRL + Qt . Key_C )) self . utilButton . setMenu ( util ) self . show () self . raise_ () \"\"\" I/O Methods \"\"\" def updateControls ( self ): \"\"\"Updates interface from model variables\"\"\" self . wEdit . setText ( str ( self . input_data . w )) self . hEdit . setText ( str ( self . input_data . h )) self . dEdit . setText ( str ( self . input_data . d )) self . tEdit . setText ( str ( self . input_data . t )) self . pEdit . setText ( str ( self . input_data . p )) self . kxEdit . setText ( str ( self . input_data . kx )) self . kyEdit . setText ( str ( self . input_data . ky )) self . meshLabel . setText ( str ( self . input_data . el_size_factor )) self . meshSlider . setValue ( int ( self . input_data . el_size_factor * 10 )) self . stepEdit . setText ( str ( self . input_data . steps )) if self . input_data . dStudy : self . dRadio . setChecked ( True ) self . endEdit . setText ( str ( self . input_data . dEnd )) else : self . tRadio . setChecked ( True ) self . endEdit . setText ( str ( self . input_data . tEnd )) def updateModel ( self ): \"\"\"Updates model variables from interface\"\"\" try : self . input_data . w = float ( self . wEdit . text ()) self . input_data . h = float ( self . hEdit . text ()) self . input_data . d = float ( self . dEdit . text ()) self . input_data . t = float ( self . tEdit . text ()) self . input_data . p = float ( self . pEdit . text ()) self . input_data . kx = float ( self . kxEdit . text ()) self . input_data . ky = float ( self . kyEdit . text ()) self . input_data . el_size_factor = float ( self . meshSlider . value () / 10 ) self . input_data . dStudy = self . dRadio . isChecked () self . input_data . steps = int ( self . stepEdit . text ()) if self . input_data . dStudy : self . input_data . dEnd = float ( self . endEdit . text ()) else : self . input_data . tEnd = float ( self . endEdit . text ()) except Exception : QMessageBox . information ( self , \"Message\" , \"Model could not be \" \"updated, \\n input should be a float.\" ) def updateEnd ( self ): \"\"\"Updates end at radio button interaction\"\"\" if self . dRadio . isChecked (): self . input_data . tEnd = float ( self . endEdit . text ()) self . endEdit . setText ( str ( self . input_data . dEnd )) else : self . input_data . dEnd = float ( self . endEdit . text ()) self . endEdit . setText ( str ( self . input_data . tEnd )) def updateName ( self ): \"\"\"Extracts and updates model name in UI\"\"\" name = os . path . basename ( self . path ) . replace ( \".json\" , \"\" ) self . nameLabel . setText ( name ) def onActionNew ( self ): \"\"\"Creates new model\"\"\" self . path = \"\" self . visualization = None self . reportPlainEdit . setPlainText ( \"\" ) self . input_data = fm . InputData () self . output_data = fm . OutputData () self . updateControls () self . updateName () def onActionOpen ( self ): \"\"\"Opens saved model\"\"\" temp_path , _ = QFileDialog . getOpenFileName ( self . ui , \"Open model\" , self . dir , \"Model (*.json)\" ) if temp_path != \"\" : if self . input_data . load ( temp_path ): self . path = temp_path self . updateControls () self . updateName () self . clearCanvas () self . visualization = None self . reportPlainEdit . setPlainText ( \"\" ) else : QMessageBox . information ( self , \"Message\" , f \"The file { os . path . basename ( temp_path ) } \" \"could not be read or was from \\n a different version than \" f \"the current version: { self . input_data . version } .\" ) def onActionSave ( self ): \"\"\"Saves current model\"\"\" self . updateModel () temp_path = self . path if temp_path == \"\" : temp_path , _ = QFileDialog . getSaveFileName ( self . ui , \"Save model\" , self . dir , \"Model (*.json)\" ) if temp_path != \"\" : if self . input_data . save ( temp_path ): self . path = temp_path self . updateName () else : QMessageBox . information ( self , \"Message\" , f \"The file { os . path . basename ( temp_path ) } \" \"could not be saved.\" ) def onActionSaveAs ( self ): \"\"\"Saves current model as new file\"\"\" self . updateModel () temp_path , _ = QFileDialog . getSaveFileName ( self . ui , \"Save model\" , self . dir , \"Model (*.json)\" ) if temp_path != \"\" : if self . input_data . save ( temp_path ): self . path = temp_path self . updateName () else : QMessageBox . information ( self , \"Message\" , f \"The file { os . path . basename ( temp_path ) } \" \"could not be saved.\" ) \"\"\" Utility methods \"\"\" def onActionExecute ( self ): \"\"\"Executes calculations on current model\"\"\" self . updateModel () if self . input_data . validModel (): self . pg . show () self . clearCanvas () self . setEnabled ( False ) self . solver = fm . Solver ( self . input_data , self . output_data , self . pg ) self . solverThread = SolverThread ( self . solver ) self . solverThread . finished . connect ( self . onSolverFinished ) self . solverThread . start () else : QMessageBox . information ( self , \"Message\" , \"Invalid model inputs. All inputs shall be \" \"larger than zero, \\n the geometry also requires that w>t and \" \"h>d.\" ) def onExecuteParamStudy ( self ): \"\"\"Executes parameter study\"\"\" self . updateModel () if self . input_data . validModel () and self . input_data . validParam (): self . pg . show () self . clearCanvas () self . setEnabled ( False ) basepath = ( self . dir + \"VTK \\\\ \" + os . path . basename ( self . path ) . replace ( \".json\" , \"\" )) self . solver = fm . Solver ( self . input_data , self . output_data , self . pg , basepath ) self . solverThread = SolverThread ( self . solver , True ) self . solverThread . finished . connect ( self . onSolverFinished ) self . solverThread . start () elif self . input_data . validModel (): QMessageBox . information ( self , \"Message\" , \"Invalid model inputs. All inputs shall be \" \"larger than zero, \\n the geometry also requires that w>t and \" \"h>d.\" ) else : QMessageBox . information ( self , \"Message\" , \"Invalid parameter-study inputs. All inputs \" \"should be larger than \\n zero, the geometry also requires that\" \" w > tEnd > t and h > dEnd > d\" ) def onSolverFinished ( self ): \"\"\"Routines when solver is finished\"\"\" self . visualization = fm . Visualization ( self . input_data , self . output_data ) if self . solverThread . paraStudy : self . reportPlainEdit . setPlainText ( \"\" ) else : txt = str ( fm . Report ( self . input_data , self . output_data )) self . reportPlainEdit . setPlainText ( txt ) self . tabWidget . setCurrentIndex ( 0 ) self . setEnabled ( True ) self . pg . exit () \"\"\" Ploting Methods \"\"\" def showGeo ( self ): \"\"\"Plots geometry\"\"\" if self . visualization is not None : self . updateCanvas ( self . visualization . showGeometry ( False )) else : self . message () def showMesh ( self ): \"\"\"Plots mesh\"\"\" if self . visualization is not None : self . updateCanvas ( self . visualization . showMesh ( False )) else : self . message () def showPizeo ( self ): \"\"\"Plots pizeometric head\"\"\" if self . visualization is not None : self . updateCanvas ( self . visualization . showPiezo ( False )) else : self . message () def showEff ( self ): \"\"\"Plots effective flux\"\"\" if self . visualization is not None : self . updateCanvas ( self . visualization . showEff ( False )) else : self . message () def showParam ( self ): \"\"\"Plots maximum effective flow for parameter study\"\"\" if self . output_data . max_flux is not None : self . updateCanvas ( self . visualization . showParam ( False )) else : QMessageBox . information ( self , \"Message\" , \"No parameter study has been calculated.\" ) def updateCanvas ( self , canvas ): \"\"\"Updates canvas with new figure\"\"\" self . tabWidget . setCurrentIndex ( 1 ) self . visualization . closeAll () self . layout . replaceWidget ( self . canvas , canvas ) self . canvas = canvas self . canvas . figure . set_facecolor ( \"#F1FAEE\" ) self . canvas . draw () def clearCanvas ( self ): \"\"\"Clears canvas of figures\"\"\" cfv . plt . close () canvas = Canvas () canvas . figure . set_facecolor ( \"#F1FAEE\" ) self . layout . replaceWidget ( self . canvas , canvas ) self . canvas = canvas def message ( self ): \"\"\"Tells user that no results exist\"\"\" QMessageBox . information ( self , \"Message\" , \"No results has been calculated.\" ) \"\"\" UI Methods \"\"\" def exit ( self ): \"\"\"Asks before terminating program\"\"\" q = QMessageBox . question ( self , \"Exit\" , \"Are you sure you want to exit the program?\" , QMessageBox . Yes | QMessageBox . No ) if q == QMessageBox . Yes : self . app . exit () self . close () def maximize ( self ): \"\"\"Maximizes or restores window\"\"\" if self . windowed : self . showMaximized () self . windowed = False self . maxiButton . setToolTip ( \"Restore\" ) self . maxiButton . setIcon ( QIcon ( self . dir + r \"Assets\\store.png\" )) else : self . showNormal () self . windowed = True self . maxiButton . setToolTip ( \"Maximize\" ) self . maxiButton . setIcon ( QIcon ( self . dir + r \"Assets\\maxi.png\" )) \"\"\" Window Movement \"\"\" def mousePressEvent ( self , event ): \"\"\"Initiates window movement\"\"\" if event . button () == Qt . LeftButton : # If (leftbutton clicked) self . offset = event . pos () # Store initial position def mouseMoveEvent ( self , event ): \"\"\"Moves window\"\"\" # If (leftbutton held, windowed, offset exist) if ( event . buttons () == Qt . LeftButton and self . windowed and self . offset is not None ): self . move ( self . pos () + event . pos () - self . offset ) # Move relative offset def mouseReleaseEvent ( self , event ): \"\"\"Suspend window movement\"\"\" self . offset = None # On release, reset offset which prevents movement clearCanvas ( self ) Clears canvas of figures Source code in src\\gwapp.py def clearCanvas ( self ): \"\"\"Clears canvas of figures\"\"\" cfv . plt . close () canvas = Canvas () canvas . figure . set_facecolor ( \"#F1FAEE\" ) self . layout . replaceWidget ( self . canvas , canvas ) self . canvas = canvas exit ( self ) Asks before terminating program Source code in src\\gwapp.py def exit ( self ): \"\"\"Asks before terminating program\"\"\" q = QMessageBox . question ( self , \"Exit\" , \"Are you sure you want to exit the program?\" , QMessageBox . Yes | QMessageBox . No ) if q == QMessageBox . Yes : self . app . exit () self . close () maximize ( self ) Maximizes or restores window Source code in src\\gwapp.py def maximize ( self ): \"\"\"Maximizes or restores window\"\"\" if self . windowed : self . showMaximized () self . windowed = False self . maxiButton . setToolTip ( \"Restore\" ) self . maxiButton . setIcon ( QIcon ( self . dir + r \"Assets\\store.png\" )) else : self . showNormal () self . windowed = True self . maxiButton . setToolTip ( \"Maximize\" ) self . maxiButton . setIcon ( QIcon ( self . dir + r \"Assets\\maxi.png\" )) message ( self ) Tells user that no results exist Source code in src\\gwapp.py def message ( self ): \"\"\"Tells user that no results exist\"\"\" QMessageBox . information ( self , \"Message\" , \"No results has been calculated.\" ) mouseMoveEvent ( self , event ) Moves window Source code in src\\gwapp.py def mouseMoveEvent ( self , event ): \"\"\"Moves window\"\"\" # If (leftbutton held, windowed, offset exist) if ( event . buttons () == Qt . LeftButton and self . windowed and self . offset is not None ): self . move ( self . pos () + event . pos () - self . offset ) # Move relative offset mousePressEvent ( self , event ) Initiates window movement Source code in src\\gwapp.py def mousePressEvent ( self , event ): \"\"\"Initiates window movement\"\"\" if event . button () == Qt . LeftButton : # If (leftbutton clicked) self . offset = event . pos () # Store initial position mouseReleaseEvent ( self , event ) Suspend window movement Source code in src\\gwapp.py def mouseReleaseEvent ( self , event ): \"\"\"Suspend window movement\"\"\" self . offset = None # On release, reset offset which prevents movement onActionExecute ( self ) Executes calculations on current model Source code in src\\gwapp.py def onActionExecute ( self ): \"\"\"Executes calculations on current model\"\"\" self . updateModel () if self . input_data . validModel (): self . pg . show () self . clearCanvas () self . setEnabled ( False ) self . solver = fm . Solver ( self . input_data , self . output_data , self . pg ) self . solverThread = SolverThread ( self . solver ) self . solverThread . finished . connect ( self . onSolverFinished ) self . solverThread . start () else : QMessageBox . information ( self , \"Message\" , \"Invalid model inputs. All inputs shall be \" \"larger than zero, \\n the geometry also requires that w>t and \" \"h>d.\" ) onActionNew ( self ) Creates new model Source code in src\\gwapp.py def onActionNew ( self ): \"\"\"Creates new model\"\"\" self . path = \"\" self . visualization = None self . reportPlainEdit . setPlainText ( \"\" ) self . input_data = fm . InputData () self . output_data = fm . OutputData () self . updateControls () self . updateName () onActionOpen ( self ) Opens saved model Source code in src\\gwapp.py def onActionOpen ( self ): \"\"\"Opens saved model\"\"\" temp_path , _ = QFileDialog . getOpenFileName ( self . ui , \"Open model\" , self . dir , \"Model (*.json)\" ) if temp_path != \"\" : if self . input_data . load ( temp_path ): self . path = temp_path self . updateControls () self . updateName () self . clearCanvas () self . visualization = None self . reportPlainEdit . setPlainText ( \"\" ) else : QMessageBox . information ( self , \"Message\" , f \"The file { os . path . basename ( temp_path ) } \" \"could not be read or was from \\n a different version than \" f \"the current version: { self . input_data . version } .\" ) onActionSave ( self ) Saves current model Source code in src\\gwapp.py def onActionSave ( self ): \"\"\"Saves current model\"\"\" self . updateModel () temp_path = self . path if temp_path == \"\" : temp_path , _ = QFileDialog . getSaveFileName ( self . ui , \"Save model\" , self . dir , \"Model (*.json)\" ) if temp_path != \"\" : if self . input_data . save ( temp_path ): self . path = temp_path self . updateName () else : QMessageBox . information ( self , \"Message\" , f \"The file { os . path . basename ( temp_path ) } \" \"could not be saved.\" ) onActionSaveAs ( self ) Saves current model as new file Source code in src\\gwapp.py def onActionSaveAs ( self ): \"\"\"Saves current model as new file\"\"\" self . updateModel () temp_path , _ = QFileDialog . getSaveFileName ( self . ui , \"Save model\" , self . dir , \"Model (*.json)\" ) if temp_path != \"\" : if self . input_data . save ( temp_path ): self . path = temp_path self . updateName () else : QMessageBox . information ( self , \"Message\" , f \"The file { os . path . basename ( temp_path ) } \" \"could not be saved.\" ) onExecuteParamStudy ( self ) Executes parameter study Source code in src\\gwapp.py def onExecuteParamStudy ( self ): \"\"\"Executes parameter study\"\"\" self . updateModel () if self . input_data . validModel () and self . input_data . validParam (): self . pg . show () self . clearCanvas () self . setEnabled ( False ) basepath = ( self . dir + \"VTK \\\\ \" + os . path . basename ( self . path ) . replace ( \".json\" , \"\" )) self . solver = fm . Solver ( self . input_data , self . output_data , self . pg , basepath ) self . solverThread = SolverThread ( self . solver , True ) self . solverThread . finished . connect ( self . onSolverFinished ) self . solverThread . start () elif self . input_data . validModel (): QMessageBox . information ( self , \"Message\" , \"Invalid model inputs. All inputs shall be \" \"larger than zero, \\n the geometry also requires that w>t and \" \"h>d.\" ) else : QMessageBox . information ( self , \"Message\" , \"Invalid parameter-study inputs. All inputs \" \"should be larger than \\n zero, the geometry also requires that\" \" w > tEnd > t and h > dEnd > d\" ) onSolverFinished ( self ) Routines when solver is finished Source code in src\\gwapp.py def onSolverFinished ( self ): \"\"\"Routines when solver is finished\"\"\" self . visualization = fm . Visualization ( self . input_data , self . output_data ) if self . solverThread . paraStudy : self . reportPlainEdit . setPlainText ( \"\" ) else : txt = str ( fm . Report ( self . input_data , self . output_data )) self . reportPlainEdit . setPlainText ( txt ) self . tabWidget . setCurrentIndex ( 0 ) self . setEnabled ( True ) self . pg . exit () showEff ( self ) Plots effective flux Source code in src\\gwapp.py def showEff ( self ): \"\"\"Plots effective flux\"\"\" if self . visualization is not None : self . updateCanvas ( self . visualization . showEff ( False )) else : self . message () showGeo ( self ) Plots geometry Source code in src\\gwapp.py def showGeo ( self ): \"\"\"Plots geometry\"\"\" if self . visualization is not None : self . updateCanvas ( self . visualization . showGeometry ( False )) else : self . message () showMesh ( self ) Plots mesh Source code in src\\gwapp.py def showMesh ( self ): \"\"\"Plots mesh\"\"\" if self . visualization is not None : self . updateCanvas ( self . visualization . showMesh ( False )) else : self . message () showParam ( self ) Plots maximum effective flow for parameter study Source code in src\\gwapp.py def showParam ( self ): \"\"\"Plots maximum effective flow for parameter study\"\"\" if self . output_data . max_flux is not None : self . updateCanvas ( self . visualization . showParam ( False )) else : QMessageBox . information ( self , \"Message\" , \"No parameter study has been calculated.\" ) showPizeo ( self ) Plots pizeometric head Source code in src\\gwapp.py def showPizeo ( self ): \"\"\"Plots pizeometric head\"\"\" if self . visualization is not None : self . updateCanvas ( self . visualization . showPiezo ( False )) else : self . message () updateCanvas ( self , canvas ) Updates canvas with new figure Source code in src\\gwapp.py def updateCanvas ( self , canvas ): \"\"\"Updates canvas with new figure\"\"\" self . tabWidget . setCurrentIndex ( 1 ) self . visualization . closeAll () self . layout . replaceWidget ( self . canvas , canvas ) self . canvas = canvas self . canvas . figure . set_facecolor ( \"#F1FAEE\" ) self . canvas . draw () updateControls ( self ) Updates interface from model variables Source code in src\\gwapp.py def updateControls ( self ): \"\"\"Updates interface from model variables\"\"\" self . wEdit . setText ( str ( self . input_data . w )) self . hEdit . setText ( str ( self . input_data . h )) self . dEdit . setText ( str ( self . input_data . d )) self . tEdit . setText ( str ( self . input_data . t )) self . pEdit . setText ( str ( self . input_data . p )) self . kxEdit . setText ( str ( self . input_data . kx )) self . kyEdit . setText ( str ( self . input_data . ky )) self . meshLabel . setText ( str ( self . input_data . el_size_factor )) self . meshSlider . setValue ( int ( self . input_data . el_size_factor * 10 )) self . stepEdit . setText ( str ( self . input_data . steps )) if self . input_data . dStudy : self . dRadio . setChecked ( True ) self . endEdit . setText ( str ( self . input_data . dEnd )) else : self . tRadio . setChecked ( True ) self . endEdit . setText ( str ( self . input_data . tEnd )) updateEnd ( self ) Updates end at radio button interaction Source code in src\\gwapp.py def updateEnd ( self ): \"\"\"Updates end at radio button interaction\"\"\" if self . dRadio . isChecked (): self . input_data . tEnd = float ( self . endEdit . text ()) self . endEdit . setText ( str ( self . input_data . dEnd )) else : self . input_data . dEnd = float ( self . endEdit . text ()) self . endEdit . setText ( str ( self . input_data . tEnd )) updateModel ( self ) Updates model variables from interface Source code in src\\gwapp.py def updateModel ( self ): \"\"\"Updates model variables from interface\"\"\" try : self . input_data . w = float ( self . wEdit . text ()) self . input_data . h = float ( self . hEdit . text ()) self . input_data . d = float ( self . dEdit . text ()) self . input_data . t = float ( self . tEdit . text ()) self . input_data . p = float ( self . pEdit . text ()) self . input_data . kx = float ( self . kxEdit . text ()) self . input_data . ky = float ( self . kyEdit . text ()) self . input_data . el_size_factor = float ( self . meshSlider . value () / 10 ) self . input_data . dStudy = self . dRadio . isChecked () self . input_data . steps = int ( self . stepEdit . text ()) if self . input_data . dStudy : self . input_data . dEnd = float ( self . endEdit . text ()) else : self . input_data . tEnd = float ( self . endEdit . text ()) except Exception : QMessageBox . information ( self , \"Message\" , \"Model could not be \" \"updated, \\n input should be a float.\" ) updateName ( self ) Extracts and updates model name in UI Source code in src\\gwapp.py def updateName ( self ): \"\"\"Extracts and updates model name in UI\"\"\" name = os . path . basename ( self . path ) . replace ( \".json\" , \"\" ) self . nameLabel . setText ( name ) Progress ( QMainWindow ) Class to display window of calculation progress Attributes: Name Type Description ui QWidget Object containing all UI elements Methods set: Sets calculation percentage and segment name exit: Resets UI elements and close window Source code in src\\gwapp.py class Progress ( QMainWindow ): \"\"\"Class to display window of calculation progress Attributes: ui (QWidget): Object containing all UI elements Methods: set: Sets calculation percentage and segment name exit: Resets UI elements and close window \"\"\" def __init__ ( self , dir ): QMainWindow . __init__ ( self ) self . ui = loadUi ( dir + \"progress.ui\" , self ) # Remove default window borders self . setWindowFlag ( Qt . FramelessWindowHint ) self . setAttribute ( Qt . WA_TranslucentBackground ) def set ( self , proc , seg ): \"\"\"Sets calculation percentage and segment name Args: proc (int): Calculation percentage seg (str): Segmentation name \"\"\" # The reference \".ui\" is not necessary, hence it is skipped throughout self . progressLabel . setText ( f \" { proc } %\" ) string = f \" { seg } \\n { self . loadLabel . text () } \" self . loadLabel . setText ( string ) def exit ( self ): \"\"\"Resets UI elements and close window\"\"\" self . progressLabel . setText ( \"0%\" ) self . loadLabel . setText ( \"\" ) self . close () exit ( self ) Resets UI elements and close window Source code in src\\gwapp.py def exit ( self ): \"\"\"Resets UI elements and close window\"\"\" self . progressLabel . setText ( \"0%\" ) self . loadLabel . setText ( \"\" ) self . close () set ( self , proc , seg ) Sets calculation percentage and segment name Parameters: Name Type Description Default proc int Calculation percentage required seg str Segmentation name required Source code in src\\gwapp.py def set ( self , proc , seg ): \"\"\"Sets calculation percentage and segment name Args: proc (int): Calculation percentage seg (str): Segmentation name \"\"\" # The reference \".ui\" is not necessary, hence it is skipped throughout self . progressLabel . setText ( f \" { proc } %\" ) string = f \" { seg } \\n { self . loadLabel . text () } \" self . loadLabel . setText ( string ) SolverThread ( QThread ) Class to use a separate thread for execute Attributes: Name Type Description solver Solver Solver object with FEM routines paraStudy bool Flag if parameter study or not Methods run: Executes FEM analysis Source code in src\\gwapp.py class SolverThread ( QThread ): \"\"\"Class to use a separate thread for execute Attributes: solver (Solver): Solver object with FEM routines paraStudy (bool): Flag if parameter study or not Methods: run: Executes FEM analysis \"\"\" def __init__ ( self , solver , paramStudy = False ): QThread . __init__ ( self ) self . solver = solver self . paraStudy = paramStudy def __del__ ( self ): self . wait () def run ( self ): \"\"\"Executes FEM analysis\"\"\" if self . paraStudy : self . solver . executeParamStudy () else : self . solver . execute () run ( self ) Executes FEM analysis Source code in src\\gwapp.py def run ( self ): \"\"\"Executes FEM analysis\"\"\" if self . paraStudy : self . solver . executeParamStudy () else : self . solver . execute ()","title":"GWapp"},{"location":"GWapp/#code-reference-gwapppy","text":"Groundwater flow app This program contains three classes and a main-script for launching an app off groundwater flow. Through the use of flowmodel.py results can be ploted for individual executions. Parameter studies are possible, with results exported to VTK-files which can be visualized within Paraview. The app utilizes pyqt5 with the design mainly being made whithin Qt Designer.","title":"Code Reference GWapp.py"},{"location":"GWapp/#src.GWapp.MainWindow","text":"Class to create app Attributes: Name Type Description path str String of current model/file path dir str String of current directory name app QApplication pg Progress Object for progress window visualization Visualization Object for plotting output data input_data InputData Object containing input data output_data OutputData Object containing output data ui QWidget Object containing all UI elements canvas FigureCanvasQTAgg Canvas to draw figures on offset - Temporary variable for movement of window windowed bool Flag if app is windowed or not Source code in src\\gwapp.py class MainWindow ( QMainWindow ): \"\"\"Class to create app Attributes: path (str): String of current model/file path dir (str): String of current directory name app (QApplication): pg (Progress): Object for progress window visualization (Visualization): Object for plotting output data input_data (InputData): Object containing input data output_data (OutputData): Object containing output data ui (QWidget): Object containing all UI elements canvas (FigureCanvasQTAgg): Canvas to draw figures on offset (-): Temporary variable for movement of window windowed (bool): Flag if app is windowed or not \"\"\" def __init__ ( self ): super ( QMainWindow , self ) . __init__ () # File Attributes self . path = \"\" self . dir = os . path . dirname ( __file__ ) + \" \\\\ \" # Window attributes self . app = app self . pg = Progress ( self . dir ) self . visualization = None self . input_data = fm . InputData () self . output_data = fm . OutputData () self . ui = loadUi ( self . dir + \"mainwindow.ui\" , self ) self . canvas = Canvas () # Flag attributes self . offset = None self . windowed = True # Create directory for VTK exports vtkdir = self . dir + \" \\\\ VTK \\\\ \" not os . path . isdir ( vtkdir ) and mkdir ( vtkdir ) # Above is a truncated if statement, \"arg and func\" = \"if arg: func\". # Window buttons self . exitButton . clicked . connect ( self . exit ) self . maxiButton . clicked . connect ( self . maximize ) self . miniButton . clicked . connect ( lambda : self . showMinimized ()) # Ploting buttons self . showGeoButton . clicked . connect ( self . showGeo ) self . showMeshButton . clicked . connect ( self . showMesh ) self . showPizeoButton . clicked . connect ( self . showPizeo ) self . showEffButton . clicked . connect ( self . showEff ) self . showParamButton . clicked . connect ( self . showParam ) # Utility buttons self . executeButton . clicked . connect ( self . onActionExecute ) self . clearCanvasButton . clicked . connect ( self . clearCanvas ) # Mesh size slider self . meshSlider . valueChanged . connect ( lambda : self . meshLabel . setText ( str ( self . meshSlider . value () / 10 ))) # Parameter study interface self . dRadio . toggled . connect ( self . updateEnd ) self . paraButton . clicked . connect ( self . onExecuteParamStudy ) # Visualization canvas self . canvas . figure . set_facecolor ( \"#F1FAEE\" ) self . layout = QVBoxLayout () self . layout . addWidget ( self . canvas ) self . figureFrame . setLayout ( self . layout ) # Sizegrip to resize window, southwest corner self . sizegrip = QSizeGrip ( self . cornerFrame ) self . sizegrip . setToolTip ( \"Grip to move\" ) # Remove default window borders self . setWindowFlag ( Qt . FramelessWindowHint ) self . setAttribute ( Qt . WA_TranslucentBackground ) # Set program (taskbar) icon, gives Windows an unique application ID self . setWindowIcon ( QIcon ( self . dir + r \"Assets\\icon.png\" )) ctypes . windll . shell32 . SetCurrentProcessExplicitAppUserModelID ( \"GWapp\" ) # Menubar menus stylesheet = \"\"\" QMenu { color: rgb(241, 250, 238); background-color: rgb(15, 27, 44); border: 5px solid rgb(15, 27, 44); } QMenu::item:selected { background-color: rgb(29, 53, 87); }\"\"\" # File menu file = QMenu () file . setStyleSheet ( stylesheet ) file . addAction ( QIcon ( self . dir + r \"Assets\\page.png\" ), \"New\" , self . onActionNew , QKeySequence ( Qt . CTRL + Qt . Key_N )) file . addAction ( QIcon ( self . dir + r \"Assets\\open.png\" ), \"Open\" , self . onActionOpen , QKeySequence ( Qt . CTRL + Qt . Key_O )) file . addSeparator () file . addAction ( QIcon ( self . dir + r \"Assets\\save.png\" ), \"Save\" , self . onActionSave , QKeySequence ( Qt . CTRL + Qt . Key_S )) file . addAction ( QIcon ( self . dir + r \"Assets\\saveas.png\" ), \"SaveAs\" , self . onActionSaveAs , QKeySequence ( Qt . CTRL + Qt . ALT + Qt . Key_S )) file . addSeparator () file . addAction ( QIcon ( self . dir + r \"Assets\\cross.png\" ), \"Exit\" , self . exit , QKeySequence ( Qt . CTRL + Qt . Key_E )) self . fileButton . setMenu ( file ) # Utility menu util = QMenu () util . setStyleSheet ( stylesheet ) util . addAction ( QIcon ( self . dir + r \"Assets\\play.png\" ), \"Execute\" , self . onActionExecute , QKeySequence ( Qt . CTRL + Qt . Key_Return )) util . addAction ( QIcon ( self . dir + r \"Assets\\para.png\" ), \"Parameter study\" , self . onExecuteParamStudy , QKeySequence ( Qt . CTRL + Qt . ALT + Qt . Key_Return )) util . addSeparator () util . addAction ( QIcon ( self . dir + r \"Assets\\clear.png\" ), \"Clear Canvas\" , self . clearCanvas , QKeySequence ( Qt . CTRL + Qt . Key_C )) self . utilButton . setMenu ( util ) self . show () self . raise_ () \"\"\" I/O Methods \"\"\" def updateControls ( self ): \"\"\"Updates interface from model variables\"\"\" self . wEdit . setText ( str ( self . input_data . w )) self . hEdit . setText ( str ( self . input_data . h )) self . dEdit . setText ( str ( self . input_data . d )) self . tEdit . setText ( str ( self . input_data . t )) self . pEdit . setText ( str ( self . input_data . p )) self . kxEdit . setText ( str ( self . input_data . kx )) self . kyEdit . setText ( str ( self . input_data . ky )) self . meshLabel . setText ( str ( self . input_data . el_size_factor )) self . meshSlider . setValue ( int ( self . input_data . el_size_factor * 10 )) self . stepEdit . setText ( str ( self . input_data . steps )) if self . input_data . dStudy : self . dRadio . setChecked ( True ) self . endEdit . setText ( str ( self . input_data . dEnd )) else : self . tRadio . setChecked ( True ) self . endEdit . setText ( str ( self . input_data . tEnd )) def updateModel ( self ): \"\"\"Updates model variables from interface\"\"\" try : self . input_data . w = float ( self . wEdit . text ()) self . input_data . h = float ( self . hEdit . text ()) self . input_data . d = float ( self . dEdit . text ()) self . input_data . t = float ( self . tEdit . text ()) self . input_data . p = float ( self . pEdit . text ()) self . input_data . kx = float ( self . kxEdit . text ()) self . input_data . ky = float ( self . kyEdit . text ()) self . input_data . el_size_factor = float ( self . meshSlider . value () / 10 ) self . input_data . dStudy = self . dRadio . isChecked () self . input_data . steps = int ( self . stepEdit . text ()) if self . input_data . dStudy : self . input_data . dEnd = float ( self . endEdit . text ()) else : self . input_data . tEnd = float ( self . endEdit . text ()) except Exception : QMessageBox . information ( self , \"Message\" , \"Model could not be \" \"updated, \\n input should be a float.\" ) def updateEnd ( self ): \"\"\"Updates end at radio button interaction\"\"\" if self . dRadio . isChecked (): self . input_data . tEnd = float ( self . endEdit . text ()) self . endEdit . setText ( str ( self . input_data . dEnd )) else : self . input_data . dEnd = float ( self . endEdit . text ()) self . endEdit . setText ( str ( self . input_data . tEnd )) def updateName ( self ): \"\"\"Extracts and updates model name in UI\"\"\" name = os . path . basename ( self . path ) . replace ( \".json\" , \"\" ) self . nameLabel . setText ( name ) def onActionNew ( self ): \"\"\"Creates new model\"\"\" self . path = \"\" self . visualization = None self . reportPlainEdit . setPlainText ( \"\" ) self . input_data = fm . InputData () self . output_data = fm . OutputData () self . updateControls () self . updateName () def onActionOpen ( self ): \"\"\"Opens saved model\"\"\" temp_path , _ = QFileDialog . getOpenFileName ( self . ui , \"Open model\" , self . dir , \"Model (*.json)\" ) if temp_path != \"\" : if self . input_data . load ( temp_path ): self . path = temp_path self . updateControls () self . updateName () self . clearCanvas () self . visualization = None self . reportPlainEdit . setPlainText ( \"\" ) else : QMessageBox . information ( self , \"Message\" , f \"The file { os . path . basename ( temp_path ) } \" \"could not be read or was from \\n a different version than \" f \"the current version: { self . input_data . version } .\" ) def onActionSave ( self ): \"\"\"Saves current model\"\"\" self . updateModel () temp_path = self . path if temp_path == \"\" : temp_path , _ = QFileDialog . getSaveFileName ( self . ui , \"Save model\" , self . dir , \"Model (*.json)\" ) if temp_path != \"\" : if self . input_data . save ( temp_path ): self . path = temp_path self . updateName () else : QMessageBox . information ( self , \"Message\" , f \"The file { os . path . basename ( temp_path ) } \" \"could not be saved.\" ) def onActionSaveAs ( self ): \"\"\"Saves current model as new file\"\"\" self . updateModel () temp_path , _ = QFileDialog . getSaveFileName ( self . ui , \"Save model\" , self . dir , \"Model (*.json)\" ) if temp_path != \"\" : if self . input_data . save ( temp_path ): self . path = temp_path self . updateName () else : QMessageBox . information ( self , \"Message\" , f \"The file { os . path . basename ( temp_path ) } \" \"could not be saved.\" ) \"\"\" Utility methods \"\"\" def onActionExecute ( self ): \"\"\"Executes calculations on current model\"\"\" self . updateModel () if self . input_data . validModel (): self . pg . show () self . clearCanvas () self . setEnabled ( False ) self . solver = fm . Solver ( self . input_data , self . output_data , self . pg ) self . solverThread = SolverThread ( self . solver ) self . solverThread . finished . connect ( self . onSolverFinished ) self . solverThread . start () else : QMessageBox . information ( self , \"Message\" , \"Invalid model inputs. All inputs shall be \" \"larger than zero, \\n the geometry also requires that w>t and \" \"h>d.\" ) def onExecuteParamStudy ( self ): \"\"\"Executes parameter study\"\"\" self . updateModel () if self . input_data . validModel () and self . input_data . validParam (): self . pg . show () self . clearCanvas () self . setEnabled ( False ) basepath = ( self . dir + \"VTK \\\\ \" + os . path . basename ( self . path ) . replace ( \".json\" , \"\" )) self . solver = fm . Solver ( self . input_data , self . output_data , self . pg , basepath ) self . solverThread = SolverThread ( self . solver , True ) self . solverThread . finished . connect ( self . onSolverFinished ) self . solverThread . start () elif self . input_data . validModel (): QMessageBox . information ( self , \"Message\" , \"Invalid model inputs. All inputs shall be \" \"larger than zero, \\n the geometry also requires that w>t and \" \"h>d.\" ) else : QMessageBox . information ( self , \"Message\" , \"Invalid parameter-study inputs. All inputs \" \"should be larger than \\n zero, the geometry also requires that\" \" w > tEnd > t and h > dEnd > d\" ) def onSolverFinished ( self ): \"\"\"Routines when solver is finished\"\"\" self . visualization = fm . Visualization ( self . input_data , self . output_data ) if self . solverThread . paraStudy : self . reportPlainEdit . setPlainText ( \"\" ) else : txt = str ( fm . Report ( self . input_data , self . output_data )) self . reportPlainEdit . setPlainText ( txt ) self . tabWidget . setCurrentIndex ( 0 ) self . setEnabled ( True ) self . pg . exit () \"\"\" Ploting Methods \"\"\" def showGeo ( self ): \"\"\"Plots geometry\"\"\" if self . visualization is not None : self . updateCanvas ( self . visualization . showGeometry ( False )) else : self . message () def showMesh ( self ): \"\"\"Plots mesh\"\"\" if self . visualization is not None : self . updateCanvas ( self . visualization . showMesh ( False )) else : self . message () def showPizeo ( self ): \"\"\"Plots pizeometric head\"\"\" if self . visualization is not None : self . updateCanvas ( self . visualization . showPiezo ( False )) else : self . message () def showEff ( self ): \"\"\"Plots effective flux\"\"\" if self . visualization is not None : self . updateCanvas ( self . visualization . showEff ( False )) else : self . message () def showParam ( self ): \"\"\"Plots maximum effective flow for parameter study\"\"\" if self . output_data . max_flux is not None : self . updateCanvas ( self . visualization . showParam ( False )) else : QMessageBox . information ( self , \"Message\" , \"No parameter study has been calculated.\" ) def updateCanvas ( self , canvas ): \"\"\"Updates canvas with new figure\"\"\" self . tabWidget . setCurrentIndex ( 1 ) self . visualization . closeAll () self . layout . replaceWidget ( self . canvas , canvas ) self . canvas = canvas self . canvas . figure . set_facecolor ( \"#F1FAEE\" ) self . canvas . draw () def clearCanvas ( self ): \"\"\"Clears canvas of figures\"\"\" cfv . plt . close () canvas = Canvas () canvas . figure . set_facecolor ( \"#F1FAEE\" ) self . layout . replaceWidget ( self . canvas , canvas ) self . canvas = canvas def message ( self ): \"\"\"Tells user that no results exist\"\"\" QMessageBox . information ( self , \"Message\" , \"No results has been calculated.\" ) \"\"\" UI Methods \"\"\" def exit ( self ): \"\"\"Asks before terminating program\"\"\" q = QMessageBox . question ( self , \"Exit\" , \"Are you sure you want to exit the program?\" , QMessageBox . Yes | QMessageBox . No ) if q == QMessageBox . Yes : self . app . exit () self . close () def maximize ( self ): \"\"\"Maximizes or restores window\"\"\" if self . windowed : self . showMaximized () self . windowed = False self . maxiButton . setToolTip ( \"Restore\" ) self . maxiButton . setIcon ( QIcon ( self . dir + r \"Assets\\store.png\" )) else : self . showNormal () self . windowed = True self . maxiButton . setToolTip ( \"Maximize\" ) self . maxiButton . setIcon ( QIcon ( self . dir + r \"Assets\\maxi.png\" )) \"\"\" Window Movement \"\"\" def mousePressEvent ( self , event ): \"\"\"Initiates window movement\"\"\" if event . button () == Qt . LeftButton : # If (leftbutton clicked) self . offset = event . pos () # Store initial position def mouseMoveEvent ( self , event ): \"\"\"Moves window\"\"\" # If (leftbutton held, windowed, offset exist) if ( event . buttons () == Qt . LeftButton and self . windowed and self . offset is not None ): self . move ( self . pos () + event . pos () - self . offset ) # Move relative offset def mouseReleaseEvent ( self , event ): \"\"\"Suspend window movement\"\"\" self . offset = None # On release, reset offset which prevents movement","title":"MainWindow"},{"location":"GWapp/#src.GWapp.MainWindow.clearCanvas","text":"Clears canvas of figures Source code in src\\gwapp.py def clearCanvas ( self ): \"\"\"Clears canvas of figures\"\"\" cfv . plt . close () canvas = Canvas () canvas . figure . set_facecolor ( \"#F1FAEE\" ) self . layout . replaceWidget ( self . canvas , canvas ) self . canvas = canvas","title":"clearCanvas()"},{"location":"GWapp/#src.GWapp.MainWindow.exit","text":"Asks before terminating program Source code in src\\gwapp.py def exit ( self ): \"\"\"Asks before terminating program\"\"\" q = QMessageBox . question ( self , \"Exit\" , \"Are you sure you want to exit the program?\" , QMessageBox . Yes | QMessageBox . No ) if q == QMessageBox . Yes : self . app . exit () self . close ()","title":"exit()"},{"location":"GWapp/#src.GWapp.MainWindow.maximize","text":"Maximizes or restores window Source code in src\\gwapp.py def maximize ( self ): \"\"\"Maximizes or restores window\"\"\" if self . windowed : self . showMaximized () self . windowed = False self . maxiButton . setToolTip ( \"Restore\" ) self . maxiButton . setIcon ( QIcon ( self . dir + r \"Assets\\store.png\" )) else : self . showNormal () self . windowed = True self . maxiButton . setToolTip ( \"Maximize\" ) self . maxiButton . setIcon ( QIcon ( self . dir + r \"Assets\\maxi.png\" ))","title":"maximize()"},{"location":"GWapp/#src.GWapp.MainWindow.message","text":"Tells user that no results exist Source code in src\\gwapp.py def message ( self ): \"\"\"Tells user that no results exist\"\"\" QMessageBox . information ( self , \"Message\" , \"No results has been calculated.\" )","title":"message()"},{"location":"GWapp/#src.GWapp.MainWindow.mouseMoveEvent","text":"Moves window Source code in src\\gwapp.py def mouseMoveEvent ( self , event ): \"\"\"Moves window\"\"\" # If (leftbutton held, windowed, offset exist) if ( event . buttons () == Qt . LeftButton and self . windowed and self . offset is not None ): self . move ( self . pos () + event . pos () - self . offset ) # Move relative offset","title":"mouseMoveEvent()"},{"location":"GWapp/#src.GWapp.MainWindow.mousePressEvent","text":"Initiates window movement Source code in src\\gwapp.py def mousePressEvent ( self , event ): \"\"\"Initiates window movement\"\"\" if event . button () == Qt . LeftButton : # If (leftbutton clicked) self . offset = event . pos () # Store initial position","title":"mousePressEvent()"},{"location":"GWapp/#src.GWapp.MainWindow.mouseReleaseEvent","text":"Suspend window movement Source code in src\\gwapp.py def mouseReleaseEvent ( self , event ): \"\"\"Suspend window movement\"\"\" self . offset = None # On release, reset offset which prevents movement","title":"mouseReleaseEvent()"},{"location":"GWapp/#src.GWapp.MainWindow.onActionExecute","text":"Executes calculations on current model Source code in src\\gwapp.py def onActionExecute ( self ): \"\"\"Executes calculations on current model\"\"\" self . updateModel () if self . input_data . validModel (): self . pg . show () self . clearCanvas () self . setEnabled ( False ) self . solver = fm . Solver ( self . input_data , self . output_data , self . pg ) self . solverThread = SolverThread ( self . solver ) self . solverThread . finished . connect ( self . onSolverFinished ) self . solverThread . start () else : QMessageBox . information ( self , \"Message\" , \"Invalid model inputs. All inputs shall be \" \"larger than zero, \\n the geometry also requires that w>t and \" \"h>d.\" )","title":"onActionExecute()"},{"location":"GWapp/#src.GWapp.MainWindow.onActionNew","text":"Creates new model Source code in src\\gwapp.py def onActionNew ( self ): \"\"\"Creates new model\"\"\" self . path = \"\" self . visualization = None self . reportPlainEdit . setPlainText ( \"\" ) self . input_data = fm . InputData () self . output_data = fm . OutputData () self . updateControls () self . updateName ()","title":"onActionNew()"},{"location":"GWapp/#src.GWapp.MainWindow.onActionOpen","text":"Opens saved model Source code in src\\gwapp.py def onActionOpen ( self ): \"\"\"Opens saved model\"\"\" temp_path , _ = QFileDialog . getOpenFileName ( self . ui , \"Open model\" , self . dir , \"Model (*.json)\" ) if temp_path != \"\" : if self . input_data . load ( temp_path ): self . path = temp_path self . updateControls () self . updateName () self . clearCanvas () self . visualization = None self . reportPlainEdit . setPlainText ( \"\" ) else : QMessageBox . information ( self , \"Message\" , f \"The file { os . path . basename ( temp_path ) } \" \"could not be read or was from \\n a different version than \" f \"the current version: { self . input_data . version } .\" )","title":"onActionOpen()"},{"location":"GWapp/#src.GWapp.MainWindow.onActionSave","text":"Saves current model Source code in src\\gwapp.py def onActionSave ( self ): \"\"\"Saves current model\"\"\" self . updateModel () temp_path = self . path if temp_path == \"\" : temp_path , _ = QFileDialog . getSaveFileName ( self . ui , \"Save model\" , self . dir , \"Model (*.json)\" ) if temp_path != \"\" : if self . input_data . save ( temp_path ): self . path = temp_path self . updateName () else : QMessageBox . information ( self , \"Message\" , f \"The file { os . path . basename ( temp_path ) } \" \"could not be saved.\" )","title":"onActionSave()"},{"location":"GWapp/#src.GWapp.MainWindow.onActionSaveAs","text":"Saves current model as new file Source code in src\\gwapp.py def onActionSaveAs ( self ): \"\"\"Saves current model as new file\"\"\" self . updateModel () temp_path , _ = QFileDialog . getSaveFileName ( self . ui , \"Save model\" , self . dir , \"Model (*.json)\" ) if temp_path != \"\" : if self . input_data . save ( temp_path ): self . path = temp_path self . updateName () else : QMessageBox . information ( self , \"Message\" , f \"The file { os . path . basename ( temp_path ) } \" \"could not be saved.\" )","title":"onActionSaveAs()"},{"location":"GWapp/#src.GWapp.MainWindow.onExecuteParamStudy","text":"Executes parameter study Source code in src\\gwapp.py def onExecuteParamStudy ( self ): \"\"\"Executes parameter study\"\"\" self . updateModel () if self . input_data . validModel () and self . input_data . validParam (): self . pg . show () self . clearCanvas () self . setEnabled ( False ) basepath = ( self . dir + \"VTK \\\\ \" + os . path . basename ( self . path ) . replace ( \".json\" , \"\" )) self . solver = fm . Solver ( self . input_data , self . output_data , self . pg , basepath ) self . solverThread = SolverThread ( self . solver , True ) self . solverThread . finished . connect ( self . onSolverFinished ) self . solverThread . start () elif self . input_data . validModel (): QMessageBox . information ( self , \"Message\" , \"Invalid model inputs. All inputs shall be \" \"larger than zero, \\n the geometry also requires that w>t and \" \"h>d.\" ) else : QMessageBox . information ( self , \"Message\" , \"Invalid parameter-study inputs. All inputs \" \"should be larger than \\n zero, the geometry also requires that\" \" w > tEnd > t and h > dEnd > d\" )","title":"onExecuteParamStudy()"},{"location":"GWapp/#src.GWapp.MainWindow.onSolverFinished","text":"Routines when solver is finished Source code in src\\gwapp.py def onSolverFinished ( self ): \"\"\"Routines when solver is finished\"\"\" self . visualization = fm . Visualization ( self . input_data , self . output_data ) if self . solverThread . paraStudy : self . reportPlainEdit . setPlainText ( \"\" ) else : txt = str ( fm . Report ( self . input_data , self . output_data )) self . reportPlainEdit . setPlainText ( txt ) self . tabWidget . setCurrentIndex ( 0 ) self . setEnabled ( True ) self . pg . exit ()","title":"onSolverFinished()"},{"location":"GWapp/#src.GWapp.MainWindow.showEff","text":"Plots effective flux Source code in src\\gwapp.py def showEff ( self ): \"\"\"Plots effective flux\"\"\" if self . visualization is not None : self . updateCanvas ( self . visualization . showEff ( False )) else : self . message ()","title":"showEff()"},{"location":"GWapp/#src.GWapp.MainWindow.showGeo","text":"Plots geometry Source code in src\\gwapp.py def showGeo ( self ): \"\"\"Plots geometry\"\"\" if self . visualization is not None : self . updateCanvas ( self . visualization . showGeometry ( False )) else : self . message ()","title":"showGeo()"},{"location":"GWapp/#src.GWapp.MainWindow.showMesh","text":"Plots mesh Source code in src\\gwapp.py def showMesh ( self ): \"\"\"Plots mesh\"\"\" if self . visualization is not None : self . updateCanvas ( self . visualization . showMesh ( False )) else : self . message ()","title":"showMesh()"},{"location":"GWapp/#src.GWapp.MainWindow.showParam","text":"Plots maximum effective flow for parameter study Source code in src\\gwapp.py def showParam ( self ): \"\"\"Plots maximum effective flow for parameter study\"\"\" if self . output_data . max_flux is not None : self . updateCanvas ( self . visualization . showParam ( False )) else : QMessageBox . information ( self , \"Message\" , \"No parameter study has been calculated.\" )","title":"showParam()"},{"location":"GWapp/#src.GWapp.MainWindow.showPizeo","text":"Plots pizeometric head Source code in src\\gwapp.py def showPizeo ( self ): \"\"\"Plots pizeometric head\"\"\" if self . visualization is not None : self . updateCanvas ( self . visualization . showPiezo ( False )) else : self . message ()","title":"showPizeo()"},{"location":"GWapp/#src.GWapp.MainWindow.updateCanvas","text":"Updates canvas with new figure Source code in src\\gwapp.py def updateCanvas ( self , canvas ): \"\"\"Updates canvas with new figure\"\"\" self . tabWidget . setCurrentIndex ( 1 ) self . visualization . closeAll () self . layout . replaceWidget ( self . canvas , canvas ) self . canvas = canvas self . canvas . figure . set_facecolor ( \"#F1FAEE\" ) self . canvas . draw ()","title":"updateCanvas()"},{"location":"GWapp/#src.GWapp.MainWindow.updateControls","text":"Updates interface from model variables Source code in src\\gwapp.py def updateControls ( self ): \"\"\"Updates interface from model variables\"\"\" self . wEdit . setText ( str ( self . input_data . w )) self . hEdit . setText ( str ( self . input_data . h )) self . dEdit . setText ( str ( self . input_data . d )) self . tEdit . setText ( str ( self . input_data . t )) self . pEdit . setText ( str ( self . input_data . p )) self . kxEdit . setText ( str ( self . input_data . kx )) self . kyEdit . setText ( str ( self . input_data . ky )) self . meshLabel . setText ( str ( self . input_data . el_size_factor )) self . meshSlider . setValue ( int ( self . input_data . el_size_factor * 10 )) self . stepEdit . setText ( str ( self . input_data . steps )) if self . input_data . dStudy : self . dRadio . setChecked ( True ) self . endEdit . setText ( str ( self . input_data . dEnd )) else : self . tRadio . setChecked ( True ) self . endEdit . setText ( str ( self . input_data . tEnd ))","title":"updateControls()"},{"location":"GWapp/#src.GWapp.MainWindow.updateEnd","text":"Updates end at radio button interaction Source code in src\\gwapp.py def updateEnd ( self ): \"\"\"Updates end at radio button interaction\"\"\" if self . dRadio . isChecked (): self . input_data . tEnd = float ( self . endEdit . text ()) self . endEdit . setText ( str ( self . input_data . dEnd )) else : self . input_data . dEnd = float ( self . endEdit . text ()) self . endEdit . setText ( str ( self . input_data . tEnd ))","title":"updateEnd()"},{"location":"GWapp/#src.GWapp.MainWindow.updateModel","text":"Updates model variables from interface Source code in src\\gwapp.py def updateModel ( self ): \"\"\"Updates model variables from interface\"\"\" try : self . input_data . w = float ( self . wEdit . text ()) self . input_data . h = float ( self . hEdit . text ()) self . input_data . d = float ( self . dEdit . text ()) self . input_data . t = float ( self . tEdit . text ()) self . input_data . p = float ( self . pEdit . text ()) self . input_data . kx = float ( self . kxEdit . text ()) self . input_data . ky = float ( self . kyEdit . text ()) self . input_data . el_size_factor = float ( self . meshSlider . value () / 10 ) self . input_data . dStudy = self . dRadio . isChecked () self . input_data . steps = int ( self . stepEdit . text ()) if self . input_data . dStudy : self . input_data . dEnd = float ( self . endEdit . text ()) else : self . input_data . tEnd = float ( self . endEdit . text ()) except Exception : QMessageBox . information ( self , \"Message\" , \"Model could not be \" \"updated, \\n input should be a float.\" )","title":"updateModel()"},{"location":"GWapp/#src.GWapp.MainWindow.updateName","text":"Extracts and updates model name in UI Source code in src\\gwapp.py def updateName ( self ): \"\"\"Extracts and updates model name in UI\"\"\" name = os . path . basename ( self . path ) . replace ( \".json\" , \"\" ) self . nameLabel . setText ( name )","title":"updateName()"},{"location":"GWapp/#src.GWapp.Progress","text":"Class to display window of calculation progress Attributes: Name Type Description ui QWidget Object containing all UI elements Methods set: Sets calculation percentage and segment name exit: Resets UI elements and close window Source code in src\\gwapp.py class Progress ( QMainWindow ): \"\"\"Class to display window of calculation progress Attributes: ui (QWidget): Object containing all UI elements Methods: set: Sets calculation percentage and segment name exit: Resets UI elements and close window \"\"\" def __init__ ( self , dir ): QMainWindow . __init__ ( self ) self . ui = loadUi ( dir + \"progress.ui\" , self ) # Remove default window borders self . setWindowFlag ( Qt . FramelessWindowHint ) self . setAttribute ( Qt . WA_TranslucentBackground ) def set ( self , proc , seg ): \"\"\"Sets calculation percentage and segment name Args: proc (int): Calculation percentage seg (str): Segmentation name \"\"\" # The reference \".ui\" is not necessary, hence it is skipped throughout self . progressLabel . setText ( f \" { proc } %\" ) string = f \" { seg } \\n { self . loadLabel . text () } \" self . loadLabel . setText ( string ) def exit ( self ): \"\"\"Resets UI elements and close window\"\"\" self . progressLabel . setText ( \"0%\" ) self . loadLabel . setText ( \"\" ) self . close ()","title":"Progress"},{"location":"GWapp/#src.GWapp.Progress.exit","text":"Resets UI elements and close window Source code in src\\gwapp.py def exit ( self ): \"\"\"Resets UI elements and close window\"\"\" self . progressLabel . setText ( \"0%\" ) self . loadLabel . setText ( \"\" ) self . close ()","title":"exit()"},{"location":"GWapp/#src.GWapp.Progress.set","text":"Sets calculation percentage and segment name Parameters: Name Type Description Default proc int Calculation percentage required seg str Segmentation name required Source code in src\\gwapp.py def set ( self , proc , seg ): \"\"\"Sets calculation percentage and segment name Args: proc (int): Calculation percentage seg (str): Segmentation name \"\"\" # The reference \".ui\" is not necessary, hence it is skipped throughout self . progressLabel . setText ( f \" { proc } %\" ) string = f \" { seg } \\n { self . loadLabel . text () } \" self . loadLabel . setText ( string )","title":"set()"},{"location":"GWapp/#src.GWapp.SolverThread","text":"Class to use a separate thread for execute Attributes: Name Type Description solver Solver Solver object with FEM routines paraStudy bool Flag if parameter study or not Methods run: Executes FEM analysis Source code in src\\gwapp.py class SolverThread ( QThread ): \"\"\"Class to use a separate thread for execute Attributes: solver (Solver): Solver object with FEM routines paraStudy (bool): Flag if parameter study or not Methods: run: Executes FEM analysis \"\"\" def __init__ ( self , solver , paramStudy = False ): QThread . __init__ ( self ) self . solver = solver self . paraStudy = paramStudy def __del__ ( self ): self . wait () def run ( self ): \"\"\"Executes FEM analysis\"\"\" if self . paraStudy : self . solver . executeParamStudy () else : self . solver . execute ()","title":"SolverThread"},{"location":"GWapp/#src.GWapp.SolverThread.run","text":"Executes FEM analysis Source code in src\\gwapp.py def run ( self ): \"\"\"Executes FEM analysis\"\"\" if self . paraStudy : self . solver . executeParamStudy () else : self . solver . execute ()","title":"run()"},{"location":"GroundwaterFlow/","text":"Groundwater Flow Introduction Besides glaciers and icecaps, most of the worlds freshwater is stored in the ground. This water is not only stored, but flows throughout the ground between the solid particles that composes it. Understanding how this water moves is vital since it is a valuable resource providing drinking and irrigation water the world over [1]. It is also a major factor in the construction of dams, which provide hydroelectric power the world over [2]. Illustration of groundwater flow. T.C. Winter, J.W. Harvey, O.L. Franke, and W.M. Alley (1998), Groundwater flow , https://commons.wikimedia.org/wiki/File:Groundwater_flow.svg [26/05/22]. Mathematical model Groundwater flow is a kind of seepage, movement of water in porous solids, studied within the field of soil mechanics and geology. A popular way to model complex seepage is with finite element methods, both for transient and steady state problems. In this project, we focus on latter for which the following is true [4, p.315]: Constant water pressure Constant water rate of flow Constant effective stress in soil No soil deformation In order for an assumption of steady state to be valid, a number of assumptions has to be made. These are listed and explained beneath 4, p.316 : Saturated soil: Space between soil particles filled with fluid Homogenous soil: Characteristics independent of location Incompressible soil: Neither soil or water can be deformed or compressed Darcy's law is valid: Constitutive law of fluid flow through porous media Negligible capillary effects: Capillary action between soil particles and fluid causes diffusion Darcy's law One-dimensional flow through a permeable medium, is governed by Darcy's law, which states that the flow rate \\(q\\) is proportional to the derivative of the piezometric head \\(\\phi\\) by the coefficient of permeability \\(k\\) [3, p.89]. \\[ q = -k \\frac{d\\phi}{dx} \\] This equation is identical, apart from the quantities, to Fourier's law for heat flow. In fact the quantities of the constitutive law can be changed to fit a wide array of different physical problems, that have an analogous relation. By understanding one of the physical problems, one can understand principles of several others. As per the heat equation, the constitutive relation can be generalized to multiple dimensions [3, p.89]. \\[ \\textbf{q} = -\\textbf{D}\\nabla\\phi \\] Differential equation Considering a arbitrary region with a fluid supply \\(Q\\) , assuming that the volume is conserved and an incompressible fluid, the governing differential equation can be formulated [3, p.88]. \\[ \\text{div}(\\textbf{D}\\nabla\\phi) + Q = 0 \\] Boundary condition To complete the model formulation one needs boundary conditions. These can be of two different types, essential boundaries with known piezometric head, and natural with prescribed flow normal to the boundary. For a impermeable surface, the essential boundary condition is zero. Finite element model To formulate a finite element model of groundwater flow in two dimensions, the strong form is required. Hence, the differential equation is reduced to two dimensions and boundary conditions as \\(\\mathcal{L}_h\\) and \\(\\mathcal{L}_g\\) are arbitrary boundaries with natural and essential conditions respectively [3, p.83]. \\[ \\begin{matrix} \\text{div}(t\\textbf{D}\\nabla \\phi) + tQ = 0 \\hspace{10mm} \\text{in region } A \\\\ q_n = \\textbf{q}^\\text{T}\\textbf{n} = h \\hspace{15mm} \\text{on }\\mathcal{L}_h\\\\ \\phi = g \\hspace{33mm} \\text{ on }\\mathcal{L}_g \\end{matrix} \\] From the strong form a finite element model can be derived using the Galerkin method, which is presented beneath. For a complete derivation, the reader is referred to the FE formulation of two-dimensional heat flow in chapters 6,7 and 10 in Introduction to the finite element method [3]. \\[ \\begin{matrix} \\left(\\int_A \\textbf{B}^\\text{T}\\textbf{DB}t\\text{d}A\\right) \\textbf{a} = \\left(-\\int_{\\mathcal{L}_{h}}\\textbf{N}^\\text{T}ht\\text{d}\\mathcal{L} - \\int_{\\mathcal{L}_{g}}\\textbf{N}^\\text{T}q_{n}t\\text{d}\\mathcal{L}\\right) + \\int_A\\textbf{N}^\\text{T}Qt\\text{d}A\\\\ \\hspace{18mm} \\textbf{K} \\hspace{15mm} \\textbf{a} = \\hspace{35mm} \\textbf{f}_\\text{b} \\hspace{36mm} + \\hspace{13mm} \\textbf{f}_\\text{l} \\hfill \\end{matrix} \\] To solve the equation system for the nodal piezometric head \\(\\textbf{a}\\) , one needs to assemble the global stiffness matrix \\(\\textbf{K}\\) , the boundary vector \\(\\textbf{f}_\\text{b}\\) and the load vector \\(\\textbf{f}_\\text{l}\\) . Applications Understanding of groundwater flow and usage of corresponding finite element models proves useful in many cases. To give an introduction of the possible applications, two different examples are used. Drinking water Groundwater accounts for roughly 30 percent of the worlds freshwater and is only beat by glaciers and icecaps. But unlike glaciers the water of liquid form and constitutes upwards of 99 percent of the worlds liquid freshwater. It is vital for billions of lives the world over, since it is the source of roughly half the worlds drinking water, 40 percent of irrigation water and 30 percent of water within industrial use [1]. Wells are used to exploit groundwater beneath the water table under which the soil is saturated. Removing water is equivalent to a negative source term and will effect the groundwater flow in the surrounding region which will try to replenish water. If a well pumps to much water it might drain the soil which becomes unsaturated lowering the water table in a region, which might dry out other wells in its vicinity. Groundwater is a shared source and its exploitation can affect its availability [5]. It is not only water that flows through porous medium, but also liquid contaminants. The source might be incorrect waste management as landfills, dug latrines, leaking ground pipes of waste or oil. Either way, the contaminants can travel far through the ground and be extracted in wells far way. While drinking water is often treated, in emerging regions of the world this might not be the case. An large source of sickness and death is human waste management, improperly built pit latrines with little to no walls to contain waste can introduce contaminants to the groundwater and later be extracted for drinking in wells [1]. Dams Hydroelectric powerplants is the source to about 17 percent of the worlds energy production is the largest renewable source. As the world is pushing for transition from fossil fuels to renewable sources leading the way for the construction of dams and megaprojects as the Chinese Three Gorges Dam. The same potential energy that is exploited to produce electrical power when passed through turbines, is the driving force behind groundwater flow around our through the necessary dams [2]. If the flow becomes too large it can cause internal erosion known as piping, the leading cause of dam failure. With high flow the soil particles are separated further from each other reducing the shear forces between them. As shear forces is a main difference between solids and fluids, the soil becomes a semi-liquid and is follows the flow. The removing of the soil causes tunnels (pipes) to form, with less flow resistance which promotes more flow. The positive feedback loop causes a cascade, which can severely harm the structural integrity of the entire dam [6]. Catastrophic failure due to piping at Teton Dam: 1976, Idaho. WaterArchives.org (2015), IDAHO-L-0010 , https://www.flickr.com/photos/23487245@N08/5811736921 [26/05/22]. However, to model this behavior goes against some of the assumptions made earlier. A more complex model is needed to model piping. A more simple case will be modeled in this application, with a steady state solution of a simplified dam. Additional material For the one further interested in the phenomena, of groundwater flow I refer to the great illustrations and experiments on the YouTube channel Practical Engineering. They has several videos on the subject of groundwater flow , wells and dam piping . References [1] Lall, U., Josset, L and Russo, T. A Snapshot of the World's Groundwater Challenges. Annual Review of Environment and Resources, vol 45 2020. DOI: https://doi.org/10.1146/annurev-environ-102017-025800. [2] U.S. Geological Survey (USGS). Hydroelectric Power Water Use , 2018. URL: https://www.usgs.gov/special-topics/water-science-school/science/hydroelectric-power-water-use (visited on 05/25/2022). [3] Ottosen, N. and Petersson, H. Introduction to the finite element method. Pearson Education Limited, 1992. ISBN: 0-13-273877-2. [4] Kaliakin, V.N. Soil Mechanics. Butterworth-Heinemann, 2017. ISBN: 978-0-12-804491-9. DOI: https://doi.org/10.1016/B978-0-12-804491-9.01001-6. [5] U.S. Geological Survey (USGS). Aquifers and Groundwater , 2019. URL: https://www.usgs.gov/special-topics/water-science-school/science/aquifers-and-groundwater (visited on 05/24/2022). [6] Association of State Dam Safety Officials (ASDSO). Internal Erosion of Earth Dams. URL: https://damsafety.org/dam-owners/internal-erosion-of-earth-dams#Internal%20Erosion%20Basics (visited on 05/24/2022).","title":"Groundwater Flow"},{"location":"GroundwaterFlow/#groundwater-flow","text":"","title":"Groundwater Flow"},{"location":"GroundwaterFlow/#introduction","text":"Besides glaciers and icecaps, most of the worlds freshwater is stored in the ground. This water is not only stored, but flows throughout the ground between the solid particles that composes it. Understanding how this water moves is vital since it is a valuable resource providing drinking and irrigation water the world over [1]. It is also a major factor in the construction of dams, which provide hydroelectric power the world over [2]. Illustration of groundwater flow. T.C. Winter, J.W. Harvey, O.L. Franke, and W.M. Alley (1998), Groundwater flow , https://commons.wikimedia.org/wiki/File:Groundwater_flow.svg [26/05/22].","title":"Introduction"},{"location":"GroundwaterFlow/#mathematical-model","text":"Groundwater flow is a kind of seepage, movement of water in porous solids, studied within the field of soil mechanics and geology. A popular way to model complex seepage is with finite element methods, both for transient and steady state problems. In this project, we focus on latter for which the following is true [4, p.315]: Constant water pressure Constant water rate of flow Constant effective stress in soil No soil deformation In order for an assumption of steady state to be valid, a number of assumptions has to be made. These are listed and explained beneath 4, p.316 : Saturated soil: Space between soil particles filled with fluid Homogenous soil: Characteristics independent of location Incompressible soil: Neither soil or water can be deformed or compressed Darcy's law is valid: Constitutive law of fluid flow through porous media Negligible capillary effects: Capillary action between soil particles and fluid causes diffusion","title":"Mathematical model"},{"location":"GroundwaterFlow/#darcys-law","text":"One-dimensional flow through a permeable medium, is governed by Darcy's law, which states that the flow rate \\(q\\) is proportional to the derivative of the piezometric head \\(\\phi\\) by the coefficient of permeability \\(k\\) [3, p.89]. \\[ q = -k \\frac{d\\phi}{dx} \\] This equation is identical, apart from the quantities, to Fourier's law for heat flow. In fact the quantities of the constitutive law can be changed to fit a wide array of different physical problems, that have an analogous relation. By understanding one of the physical problems, one can understand principles of several others. As per the heat equation, the constitutive relation can be generalized to multiple dimensions [3, p.89]. \\[ \\textbf{q} = -\\textbf{D}\\nabla\\phi \\]","title":"Darcy's law"},{"location":"GroundwaterFlow/#differential-equation","text":"Considering a arbitrary region with a fluid supply \\(Q\\) , assuming that the volume is conserved and an incompressible fluid, the governing differential equation can be formulated [3, p.88]. \\[ \\text{div}(\\textbf{D}\\nabla\\phi) + Q = 0 \\]","title":"Differential equation"},{"location":"GroundwaterFlow/#boundary-condition","text":"To complete the model formulation one needs boundary conditions. These can be of two different types, essential boundaries with known piezometric head, and natural with prescribed flow normal to the boundary. For a impermeable surface, the essential boundary condition is zero.","title":"Boundary condition"},{"location":"GroundwaterFlow/#finite-element-model","text":"To formulate a finite element model of groundwater flow in two dimensions, the strong form is required. Hence, the differential equation is reduced to two dimensions and boundary conditions as \\(\\mathcal{L}_h\\) and \\(\\mathcal{L}_g\\) are arbitrary boundaries with natural and essential conditions respectively [3, p.83]. \\[ \\begin{matrix} \\text{div}(t\\textbf{D}\\nabla \\phi) + tQ = 0 \\hspace{10mm} \\text{in region } A \\\\ q_n = \\textbf{q}^\\text{T}\\textbf{n} = h \\hspace{15mm} \\text{on }\\mathcal{L}_h\\\\ \\phi = g \\hspace{33mm} \\text{ on }\\mathcal{L}_g \\end{matrix} \\] From the strong form a finite element model can be derived using the Galerkin method, which is presented beneath. For a complete derivation, the reader is referred to the FE formulation of two-dimensional heat flow in chapters 6,7 and 10 in Introduction to the finite element method [3]. \\[ \\begin{matrix} \\left(\\int_A \\textbf{B}^\\text{T}\\textbf{DB}t\\text{d}A\\right) \\textbf{a} = \\left(-\\int_{\\mathcal{L}_{h}}\\textbf{N}^\\text{T}ht\\text{d}\\mathcal{L} - \\int_{\\mathcal{L}_{g}}\\textbf{N}^\\text{T}q_{n}t\\text{d}\\mathcal{L}\\right) + \\int_A\\textbf{N}^\\text{T}Qt\\text{d}A\\\\ \\hspace{18mm} \\textbf{K} \\hspace{15mm} \\textbf{a} = \\hspace{35mm} \\textbf{f}_\\text{b} \\hspace{36mm} + \\hspace{13mm} \\textbf{f}_\\text{l} \\hfill \\end{matrix} \\] To solve the equation system for the nodal piezometric head \\(\\textbf{a}\\) , one needs to assemble the global stiffness matrix \\(\\textbf{K}\\) , the boundary vector \\(\\textbf{f}_\\text{b}\\) and the load vector \\(\\textbf{f}_\\text{l}\\) .","title":"Finite element model"},{"location":"GroundwaterFlow/#applications","text":"Understanding of groundwater flow and usage of corresponding finite element models proves useful in many cases. To give an introduction of the possible applications, two different examples are used.","title":"Applications"},{"location":"GroundwaterFlow/#drinking-water","text":"Groundwater accounts for roughly 30 percent of the worlds freshwater and is only beat by glaciers and icecaps. But unlike glaciers the water of liquid form and constitutes upwards of 99 percent of the worlds liquid freshwater. It is vital for billions of lives the world over, since it is the source of roughly half the worlds drinking water, 40 percent of irrigation water and 30 percent of water within industrial use [1]. Wells are used to exploit groundwater beneath the water table under which the soil is saturated. Removing water is equivalent to a negative source term and will effect the groundwater flow in the surrounding region which will try to replenish water. If a well pumps to much water it might drain the soil which becomes unsaturated lowering the water table in a region, which might dry out other wells in its vicinity. Groundwater is a shared source and its exploitation can affect its availability [5]. It is not only water that flows through porous medium, but also liquid contaminants. The source might be incorrect waste management as landfills, dug latrines, leaking ground pipes of waste or oil. Either way, the contaminants can travel far through the ground and be extracted in wells far way. While drinking water is often treated, in emerging regions of the world this might not be the case. An large source of sickness and death is human waste management, improperly built pit latrines with little to no walls to contain waste can introduce contaminants to the groundwater and later be extracted for drinking in wells [1].","title":"Drinking water"},{"location":"GroundwaterFlow/#dams","text":"Hydroelectric powerplants is the source to about 17 percent of the worlds energy production is the largest renewable source. As the world is pushing for transition from fossil fuels to renewable sources leading the way for the construction of dams and megaprojects as the Chinese Three Gorges Dam. The same potential energy that is exploited to produce electrical power when passed through turbines, is the driving force behind groundwater flow around our through the necessary dams [2]. If the flow becomes too large it can cause internal erosion known as piping, the leading cause of dam failure. With high flow the soil particles are separated further from each other reducing the shear forces between them. As shear forces is a main difference between solids and fluids, the soil becomes a semi-liquid and is follows the flow. The removing of the soil causes tunnels (pipes) to form, with less flow resistance which promotes more flow. The positive feedback loop causes a cascade, which can severely harm the structural integrity of the entire dam [6]. Catastrophic failure due to piping at Teton Dam: 1976, Idaho. WaterArchives.org (2015), IDAHO-L-0010 , https://www.flickr.com/photos/23487245@N08/5811736921 [26/05/22]. However, to model this behavior goes against some of the assumptions made earlier. A more complex model is needed to model piping. A more simple case will be modeled in this application, with a steady state solution of a simplified dam.","title":"Dams"},{"location":"GroundwaterFlow/#additional-material","text":"For the one further interested in the phenomena, of groundwater flow I refer to the great illustrations and experiments on the YouTube channel Practical Engineering. They has several videos on the subject of groundwater flow , wells and dam piping .","title":"Additional material"},{"location":"GroundwaterFlow/#references","text":"[1] Lall, U., Josset, L and Russo, T. A Snapshot of the World's Groundwater Challenges. Annual Review of Environment and Resources, vol 45 2020. DOI: https://doi.org/10.1146/annurev-environ-102017-025800. [2] U.S. Geological Survey (USGS). Hydroelectric Power Water Use , 2018. URL: https://www.usgs.gov/special-topics/water-science-school/science/hydroelectric-power-water-use (visited on 05/25/2022). [3] Ottosen, N. and Petersson, H. Introduction to the finite element method. Pearson Education Limited, 1992. ISBN: 0-13-273877-2. [4] Kaliakin, V.N. Soil Mechanics. Butterworth-Heinemann, 2017. ISBN: 978-0-12-804491-9. DOI: https://doi.org/10.1016/B978-0-12-804491-9.01001-6. [5] U.S. Geological Survey (USGS). Aquifers and Groundwater , 2019. URL: https://www.usgs.gov/special-topics/water-science-school/science/aquifers-and-groundwater (visited on 05/24/2022). [6] Association of State Dam Safety Officials (ASDSO). Internal Erosion of Earth Dams. URL: https://damsafety.org/dam-owners/internal-erosion-of-earth-dams#Internal%20Erosion%20Basics (visited on 05/24/2022).","title":"References"},{"location":"ModuleManual/","text":"Flowmodel Module Manual Missing content It was initially planned to write an manual for the flowmodel module. With limited time I was unable to finish this manual in time, and since it was not obligatory it skipped for the time being. It might be updated in the week until the presentation, but since it is not part of the assignment there is no obligation to evaluate it unless one wants to. InputData OutputData Solver Report Visualization","title":"Flowmodel Module Manual"},{"location":"ModuleManual/#flowmodel-module-manual","text":"Missing content It was initially planned to write an manual for the flowmodel module. With limited time I was unable to finish this manual in time, and since it was not obligatory it skipped for the time being. It might be updated in the week until the presentation, but since it is not part of the assignment there is no obligation to evaluate it unless one wants to.","title":"Flowmodel Module Manual"},{"location":"ModuleManual/#inputdata","text":"","title":"InputData"},{"location":"ModuleManual/#outputdata","text":"","title":"OutputData"},{"location":"ModuleManual/#solver","text":"","title":"Solver"},{"location":"ModuleManual/#report","text":"","title":"Report"},{"location":"ModuleManual/#visualization","text":"","title":"Visualization"},{"location":"flowmodel/","text":"Code Reference flowmodel.py Groundwater Flow Model This module contains a collection of five classes with combined functionality to construct a program for finite element analysis of groundwater flow. InputData Class to define geometry and manage indata for the model Attributes: Name Type Description version int Version corresponding to worksheet number w float Width of ground h float Height of ground d float Depth of dividing wall (initial if parameter study) t float Thickness of dividing wall (initial if parameter study) p float Pressure head on left side of dividing wall kx float Permeability coefficient in x-direction ky float Permeability coefficient in y-direction ep list Element thickness (calfem) el_size_factor float Maximal element size dStudy bool Flag if d is studied, otherwise t dEnd float End depth in study of d tEnd float End thickness in study of t steps int Amount of steps of parameter study Source code in src\\flowmodel.py class InputData ( object ): \"\"\"Class to define geometry and manage indata for the model Attributes: version (int): Version corresponding to worksheet number w (float): Width of ground h (float): Height of ground d (float): Depth of dividing wall (initial if parameter study) t (float): Thickness of dividing wall (initial if parameter study) p (float): Pressure head on left side of dividing wall kx (float): Permeability coefficient in x-direction ky (float): Permeability coefficient in y-direction ep (list): Element thickness (calfem) el_size_factor (float): Maximal element size dStudy (bool): Flag if d is studied, otherwise t dEnd (float): End depth in study of d tEnd (float): End thickness in study of t steps (int): Amount of steps of parameter study \"\"\" def __init__ ( self ): # Standard model self . version = 7 self . w = 50. self . h = 10. self . d = 2. self . t = 1. self . p = 10. self . kx = 20.0 self . ky = 20.0 self . ep = [ 1.0 ] self . el_size_factor = 1 # Parameter study self . dStudy = True self . dEnd = 8. self . tEnd = 10. self . steps = 10 def save ( self , path ): \"\"\"Saves indata to a .json file Args: path (str): Path (dir + name) to write to Returns: bool: True for success, False otherwise. \"\"\" input_data = {} input_data [ \"version\" ] = self . version input_data [ \"w\" ] = self . w input_data [ \"h\" ] = self . h input_data [ \"d\" ] = self . d input_data [ \"t\" ] = self . t input_data [ \"p\" ] = self . p input_data [ \"kx\" ] = self . kx input_data [ \"ky\" ] = self . ky input_data [ \"ep\" ] = self . ep input_data [ \"el_size_factor\" ] = self . el_size_factor input_data [ \"dStudy\" ] = self . dStudy input_data [ \"dEnd\" ] = self . dEnd input_data [ \"tEnd\" ] = self . tEnd input_data [ \"steps\" ] = self . steps try : with open ( path , \"w\" ) as ofile : json . dump ( input_data , ofile , sort_keys = True , indent = 4 ) return True except Exception : print ( f \"The file { path } could not be written.\" ) return False def load ( self , path ): \"\"\"Reads indata from a .json file Args: path (str): Path to read from Returns: bool: True for success, False otherwise. \"\"\" try : with open ( path , \"r\" ) as ifile : input_data = json . load ( ifile ) except Exception : print ( f \"The file { path } could not be found or read.\" ) return False if input_data [ \"version\" ] != self . version : print ( f \"The file { path } is from different version, \" \"loading was canceled.\" ) return False self . w = input_data [ \"w\" ] self . h = input_data [ \"h\" ] self . d = input_data [ \"d\" ] self . t = input_data [ \"t\" ] self . p = input_data [ \"p\" ] self . kx = input_data [ \"kx\" ] self . ky = input_data [ \"ky\" ] self . ep = input_data [ \"ep\" ] self . el_size_factor = input_data [ \"el_size_factor\" ] self . dStudy = input_data [ \"dStudy\" ] self . dEnd = input_data [ \"dEnd\" ] self . tEnd = input_data [ \"tEnd\" ] self . steps = input_data [ \"steps\" ] return True def geometry ( self ): \"\"\"Defines problem geometry Returns: Geometry: Object containing geometric data \"\"\" g = cfg . Geometry () w = self . w h = self . h t = self . t d = self . d # Points g . point ([ 0. , 0. ]) # 0 g . point ([ w , 0. ]) # 1 g . point ([ w , h ]) # 2 g . point ([( w + t ) / 2. , h ]) # 3 g . point ([( w + t ) / 2. , h - d ]) # 4 g . point ([( w - t ) / 2. , h - d ]) # 5 g . point ([( w - t ) / 2. , h ]) # 6 g . point ([ 0. , h ]) # 7 # Lines g . spline ([ 0 , 1 ]) # 0 g . spline ([ 1 , 2 ]) # 1 g . spline ([ 2 , 3 ], marker = 20 ) # 2 Open side g . spline ([ 3 , 4 ]) # 3 g . spline ([ 4 , 5 ]) # 4 g . spline ([ 5 , 6 ]) # 5 g . spline ([ 6 , 7 ], marker = 30 ) # 6 Dam side g . spline ([ 7 , 0 ]) # 7 g . surface ([ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ]) return g def validModel ( self ): \"\"\"Verifies valid model parameters A model is Valid if {w,h,d,t,p,kx,ky} > 0, w > t and h > d. Returns: bool: True if valid, false otherwise. \"\"\" notneg = [ self . w , self . h , self . d , self . t , self . p , self . kx , self . ky ] if self . w > self . t and self . h > self . d and all ( i > 0 for i in notneg ): return True return False def validParam ( self ): \"\"\"Verifies valid parameter study parameters A parameter study is valid if h > d_end > d for a study of d w > t_end > t for a study of t Returns: bool: True if valid, false otherwise. \"\"\" if self . dStudy and self . h > self . dEnd > self . d : return True elif self . w > self . tEnd > self . t : return True return False geometry ( self ) Defines problem geometry Returns: Type Description Geometry Object containing geometric data Source code in src\\flowmodel.py def geometry ( self ): \"\"\"Defines problem geometry Returns: Geometry: Object containing geometric data \"\"\" g = cfg . Geometry () w = self . w h = self . h t = self . t d = self . d # Points g . point ([ 0. , 0. ]) # 0 g . point ([ w , 0. ]) # 1 g . point ([ w , h ]) # 2 g . point ([( w + t ) / 2. , h ]) # 3 g . point ([( w + t ) / 2. , h - d ]) # 4 g . point ([( w - t ) / 2. , h - d ]) # 5 g . point ([( w - t ) / 2. , h ]) # 6 g . point ([ 0. , h ]) # 7 # Lines g . spline ([ 0 , 1 ]) # 0 g . spline ([ 1 , 2 ]) # 1 g . spline ([ 2 , 3 ], marker = 20 ) # 2 Open side g . spline ([ 3 , 4 ]) # 3 g . spline ([ 4 , 5 ]) # 4 g . spline ([ 5 , 6 ]) # 5 g . spline ([ 6 , 7 ], marker = 30 ) # 6 Dam side g . spline ([ 7 , 0 ]) # 7 g . surface ([ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ]) return g load ( self , path ) Reads indata from a .json file Parameters: Name Type Description Default path str Path to read from required Returns: Type Description bool True for success, False otherwise. Source code in src\\flowmodel.py def load ( self , path ): \"\"\"Reads indata from a .json file Args: path (str): Path to read from Returns: bool: True for success, False otherwise. \"\"\" try : with open ( path , \"r\" ) as ifile : input_data = json . load ( ifile ) except Exception : print ( f \"The file { path } could not be found or read.\" ) return False if input_data [ \"version\" ] != self . version : print ( f \"The file { path } is from different version, \" \"loading was canceled.\" ) return False self . w = input_data [ \"w\" ] self . h = input_data [ \"h\" ] self . d = input_data [ \"d\" ] self . t = input_data [ \"t\" ] self . p = input_data [ \"p\" ] self . kx = input_data [ \"kx\" ] self . ky = input_data [ \"ky\" ] self . ep = input_data [ \"ep\" ] self . el_size_factor = input_data [ \"el_size_factor\" ] self . dStudy = input_data [ \"dStudy\" ] self . dEnd = input_data [ \"dEnd\" ] self . tEnd = input_data [ \"tEnd\" ] self . steps = input_data [ \"steps\" ] return True save ( self , path ) Saves indata to a .json file Parameters: Name Type Description Default path str Path (dir + name) to write to required Returns: Type Description bool True for success, False otherwise. Source code in src\\flowmodel.py def save ( self , path ): \"\"\"Saves indata to a .json file Args: path (str): Path (dir + name) to write to Returns: bool: True for success, False otherwise. \"\"\" input_data = {} input_data [ \"version\" ] = self . version input_data [ \"w\" ] = self . w input_data [ \"h\" ] = self . h input_data [ \"d\" ] = self . d input_data [ \"t\" ] = self . t input_data [ \"p\" ] = self . p input_data [ \"kx\" ] = self . kx input_data [ \"ky\" ] = self . ky input_data [ \"ep\" ] = self . ep input_data [ \"el_size_factor\" ] = self . el_size_factor input_data [ \"dStudy\" ] = self . dStudy input_data [ \"dEnd\" ] = self . dEnd input_data [ \"tEnd\" ] = self . tEnd input_data [ \"steps\" ] = self . steps try : with open ( path , \"w\" ) as ofile : json . dump ( input_data , ofile , sort_keys = True , indent = 4 ) return True except Exception : print ( f \"The file { path } could not be written.\" ) return False validModel ( self ) Verifies valid model parameters A model is Valid if {w,h,d,t,p,kx,ky} > 0, w > t and h > d. Returns: Type Description bool True if valid, false otherwise. Source code in src\\flowmodel.py def validModel ( self ): \"\"\"Verifies valid model parameters A model is Valid if {w,h,d,t,p,kx,ky} > 0, w > t and h > d. Returns: bool: True if valid, false otherwise. \"\"\" notneg = [ self . w , self . h , self . d , self . t , self . p , self . kx , self . ky ] if self . w > self . t and self . h > self . d and all ( i > 0 for i in notneg ): return True return False validParam ( self ) Verifies valid parameter study parameters A parameter study is valid if h > d_end > d for a study of d w > t_end > t for a study of t Returns: Type Description bool True if valid, false otherwise. Source code in src\\flowmodel.py def validParam ( self ): \"\"\"Verifies valid parameter study parameters A parameter study is valid if h > d_end > d for a study of d w > t_end > t for a study of t Returns: bool: True if valid, false otherwise. \"\"\" if self . dStudy and self . h > self . dEnd > self . d : return True elif self . w > self . tEnd > self . t : return True return False OutputData Class to store the results from the calculation Attributes: Name Type Description geometry Geometry Geometric data object el_type int Element type (3-triangle) dof_per_node int Degrees of freedom per node coords array Global coordinate matrix edof array Element topology matrix dofs array Degrees of freedom matrix a array Nodal piezometric head r array Nodal reaction flux ed array Elemental piezometric head qs array Elemental volume flux qt array Elemental hydraulic gradient eff_flux array Elemental effective flux range array Range of parameter study max_flux array Maximum effective flux of parameter study Source code in src\\flowmodel.py class OutputData ( object ): \"\"\"Class to store the results from the calculation Attributes: geometry (Geometry): Geometric data object el_type (int): Element type (3-triangle) dof_per_node (int): Degrees of freedom per node coords (array): Global coordinate matrix edof (array): Element topology matrix dofs (array): Degrees of freedom matrix a (array): Nodal piezometric head r (array): Nodal reaction flux ed (array): Elemental piezometric head qs (array): Elemental volume flux qt (array): Elemental hydraulic gradient eff_flux (array): Elemental effective flux range (array): Range of parameter study max_flux (array): Maximum effective flux of parameter study \"\"\" def __init__ ( self ): # Geometry and FEM self . geometry = None self . el_type = None self . dof_per_node = None self . coords = None self . edof = None self . dofs = None # Results self . a = None self . r = None self . ed = None self . qs = None self . qt = None self . eff_flux = None # Parameter study self . range = None self . max_flux = None Report Class to present in-/outdata as a report Attributes: Name Type Description input_data InputData Object containing input data output_data OutputData Object containing output data report str String to print out as report Source code in src\\flowmodel.py class Report ( object ): \"\"\"Class to present in-/outdata as a report Attributes: input_data (InputData): Object containing input data output_data (OutputData): Object containing output data report (str): String to print out as report \"\"\" def __init__ ( self , input_data , output_data ): self . input_data = input_data self . output_data = output_data self . report = \"\" def clear ( self ): \"\"\"Clears report\"\"\" self . report = \"\" def add_text ( self , text = \"\" ): \"\"\"Adds a new line of text to report Args: text (str, optional): Text to add to report (defult is \"\") \"\"\" self . report += str ( text ) + \" \\n \" def __str__ ( self ): self . clear () # Banner s = f \"Report of Groundwater flow | Version { self . input_data . version } \" self . add_text ( f \" { '' : =^60 } \\n { s : ^60 } \\n { '' : =^60 } \" ) # Model input self . add_text () self . add_text ( f \" { ' Model input ' : ~^60 } \" ) self . add_text ( \"Element dimensions [m]\" ) self . add_text ( f \"w: { self . input_data . w } \" ) self . add_text ( f \"h: { self . input_data . h } \" ) self . add_text ( f \"d: { self . input_data . d } \" ) self . add_text ( f \"t: { self . input_data . t } \" ) self . add_text ( f \"p: { self . input_data . p } \" ) self . add_text () self . add_text ( \"Permeability [m/day]\" ) self . add_text ( f \"kx: { self . input_data . kx } \" ) self . add_text ( f \"ky: { self . input_data . ky } \" ) self . add_text () self . add_text ( \"Thickness [m]\" ) self . add_text ( f \"ep: { self . input_data . ep } \" ) self . add_text () self . add_text ( \"Maximum element size [-]\" ) self . add_text ( f \"el_size_factor: { self . input_data . el_size_factor } \" ) # Model output self . add_text () self . add_text ( f \" { ' Model Output ' : ~^60 } \" ) self . add_text ( \"Number of nodes [-]\" ) self . add_text ( f \"nnode: { self . output_data . coords . shape [ 0 ] } \" ) self . add_text () self . add_text ( \"Number of elements [-]\" ) self . add_text ( f \"nnode: { self . output_data . edof . shape [ 0 ] } \" ) self . add_text () self . add_text ( \"Maximal effective flux [m^2/day]\" ) self . add_text ( f \"Max eff_flux: { max ( self . output_data . eff_flux ) : .2f } \" ) # Per node data self . add_text () self . add_text ( \"Per Node\" ) table = tbl . tabulate ( { \" \\n Node\" : self . output_data . dofs , \"X-coord \\n [m]\" : self . output_data . coords [:, 0 ], \"Y-coord \\n [m]\" : self . output_data . coords [:, 1 ], \"Pizeometric \\n head [m]\" : self . output_data . a }, headers = \"keys\" , numalign = \"center\" , floatfmt = ( \".0f\" , \".2f\" , \".2f\" , \".2f\" ), tablefmt = \"simple\" , ) self . add_text ( table ) # Per element data self . add_text () self . add_text ( \"Per Element\" + \"{'[m^2/day]':>38}\" ) table = tbl . tabulate ( { \" \\n Elem\" : np . arange ( 1 , np . shape ( self . output_data . edof )[ 0 ] + 1 ), \"node \\n 1\" : self . output_data . edof [:, 0 ], \"node \\n 2\" : self . output_data . edof [:, 1 ], \"node \\n 3\" : self . output_data . edof [:, 2 ], \" \\n x \" : self . output_data . qs [:, 0 ], \"Flux \\n y \" : self . output_data . qs [:, 1 ], \" \\n eff \" : self . output_data . eff_flux }, headers = \"keys\" , numalign = \"center\" , floatfmt = ( \".0f\" , \".0f\" , \".0f\" , \".0f\" , \".2f\" , \".2f\" , \".2f\" , \".2f\" ), tablefmt = \"simple\" , ) self . add_text ( table ) self . add_text ( f \" { '' : =^60 } \" ) return self . report add_text ( self , text = '' ) Adds a new line of text to report Parameters: Name Type Description Default text str Text to add to report (defult is \"\") '' Source code in src\\flowmodel.py def add_text ( self , text = \"\" ): \"\"\"Adds a new line of text to report Args: text (str, optional): Text to add to report (defult is \"\") \"\"\" self . report += str ( text ) + \" \\n \" clear ( self ) Clears report Source code in src\\flowmodel.py def clear ( self ): \"\"\"Clears report\"\"\" self . report = \"\" Solver Class to handle in-/outdata with FEM solver Attributes: Name Type Description input_data InputData Object containing input data output_data OutputData Object containing output data basepath str Optional path for export to VTK pg Progress Optional progress-object to inform user of calculations Source code in src\\flowmodel.py class Solver ( object ): \"\"\"Class to handle in-/outdata with FEM solver Attributes: input_data (InputData): Object containing input data output_data (OutputData): Object containing output data basepath (str): Optional path for export to VTK pg (Progress): Optional progress-object to inform user of calculations \"\"\" def __init__ ( self , input_data , output_data , pg = False , basepath = \"\" ): self . input_data = input_data self . output_data = output_data self . pg = pg self . basepath = basepath def execute ( self ): \"\"\"Executes FEM solver routine for groundwater flow\"\"\" print ( \"Solver is being executed...\" ) self . pg and self . pg . set ( 1 , \"Staring solver...\" ) # Above is a truncated if statement, \"arg and func\" = \"if arg: func\". # If pg is specified in the constructor it returns True, since all not # empty/zero objects return True in python. # Transfer input data to local references print ( \"Importing data...\" ) self . pg and self . pg . set ( 1 , \"Importing data...\" ) # Truncated \"if\" ep = self . input_data . ep p = self . input_data . p kx = self . input_data . kx ky = self . input_data . ky geometry = self . input_data . geometry () # Mesh generation print ( \"Generating mesh...\" ) self . pg and self . pg . set ( 3 , \"Generating mesh...\" ) el_type = 2 dof_per_node = 1 mesh = cfm . GmshMeshGenerator ( geometry ) mesh . el_size_factor = self . input_data . el_size_factor mesh . el_type = el_type mesh . dofs_per_node = dof_per_node mesh . return_boundary_elements = True coords , edof , dofs , bdofs , * _ = mesh . create () # Additional variables print ( \"Preparing additional variables...\" ) self . pg and self . pg . set ( 18 , \"Preparing additional variables...\" ) ndof = np . size ( dofs ) ex , ey = cfc . coordxtr ( edof , coords , dofs ) D = np . array ([[ kx , 0. ], [ 0. , ky ]]) # Stiffness matrix print ( \"Assembling stiffness matrix...\" ) self . pg and self . pg . set ( 20 , \"Assembling stiffness matrix...\" ) K = np . zeros ([ ndof , ndof ]) for elx , ely , eldof in zip ( ex , ey , edof ): Ke = cfc . flw2te ( elx , ely , ep , D ) cfc . assem ( eldof , K , Ke ) # Load vector print ( \"Assembling force vector...\" ) self . pg and self . pg . set ( 66 , \"Assembling force vector...\" ) f = np . zeros ([ ndof , 1 ]) # Boundary conditions print ( \"Assembling boundary conditions...\" ) self . pg and self . pg . set ( 67 , \"Assembling boundary conditions...\" ) bc = np . array ([], \"i\" ) bcVal = np . array ([], \"f\" ) bc , bcVal = cfu . applybc ( bdofs , bc , bcVal , 20 , 0.0 ) # Open side bc , bcVal = cfu . applybc ( bdofs , bc , bcVal , 30 , p ) # Dam side # Solve FEM-system print ( \"Solving equation system...\" ) self . pg and self . pg . set ( 70 , \"Solving equation system...\" ) a , r = cfc . solveq ( K , f , bc , bcVal ) # Extract element values print ( \"Computing element variables...\" ) self . pg and self . pg . set ( 80 , \"Computing element variables...\" ) ed = cfc . extract_eldisp ( edof , a ) qs , qt = cfc . flw2ts ( ex , ey , D , ed ) # Calculating effective flux print ( \"Calculating effective flux...\" ) self . pg and self . pg . set ( 97 , \"Calculating effective flux...\" ) eff_flux = [] for elqs in qs : eff_flux . append ( np . sqrt ( elqs [ 0 ] ** 2 + elqs [ 1 ] ** 2 )) # Transfer local references to output data print ( \"Exporting data...\" ) self . pg and self . pg . set ( 99 , \"Exporting data...\" ) self . output_data . geometry = geometry self . output_data . el_type = el_type self . output_data . dofs_per_node = dof_per_node self . output_data . coords = coords self . output_data . edof = edof self . output_data . dofs = dofs self . output_data . a = a self . output_data . r = r self . output_data . ed = ed self . output_data . qs = qs self . output_data . qt = qt self . output_data . eff_flux = eff_flux print ( \"Solver is done.\" ) self . pg and self . pg . set ( 100 , \"Solver is done.\" ) def executeParamStudy ( self ): \"\"\"Executes parameter study and exports vtk-files\"\"\" old_d = self . input_data . d old_t = self . input_data . t if self . input_data . dStudy : dRange = np . linspace ( self . input_data . d , self . input_data . dEnd , self . input_data . steps ) self . output_data . range = dRange self . output_data . max_flux = np . zeros ( dRange . shape [ 0 ], float ) for i , d in enumerate ( dRange , 1 ): print ( f \"Executing for d = { d } ...\" ) value = int (( i - 1 ) / self . input_data . steps * 100 ) self . pg and self . pg . set ( value , f \"Executing for d = { d : .2f } ...\" ) self . input_data . d = float ( d ) solver = Solver ( self . input_data , self . output_data ) solver . execute () self . output_data . max_flux [ i - 1 ] = max ( self . output_data . eff_flux ) self . exportVtk ( f \" { self . basepath } _d { i : 03d } \" ) else : tRange = np . linspace ( self . input_data . t , self . input_data . tEnd , self . input_data . steps ) self . output_data . range = tRange self . output_data . max_flux = np . zeros ( tRange . shape [ 0 ], float ) for i , t in enumerate ( tRange , 1 ): print ( f \"Executing for t = { t } ...\" ) value = int (( i - 1 ) / self . input_data . steps * 100 ) self . pg and self . pg . set ( value , f \"Executing for t = { t : .2f } ...\" ) self . input_data . t = float ( t ) solver = Solver ( self . input_data , self . output_data ) solver . execute () self . output_data . max_flux [ i - 1 ] = max ( self . output_data . eff_flux ) self . exportVtk ( f \" { self . basepath } _t { i : 03d } \" ) self . input_data . d = old_d self . input_data . t = old_t print ( \"Parameter study is done.\" ) self . pg and self . pg . set ( 100 , \"Parameter study is done.\" ) def exportVtk ( self , path ): \"\"\"Export results to VTK format\"\"\" print ( f \"Exporting results to { path } . \\n \" ) # Expand variables to three dimensions fluxmatrix = ( np . c_ [ self . output_data . qs , np . zeros ( self . output_data . qs . shape [ 0 ])]) coordmatrix = ( np . c_ [ self . output_data . coords , np . zeros ( self . output_data . coords . shape [ 0 ])]) points = coordmatrix . tolist () polygons = ( self . output_data . edof - 1 ) . tolist () pointData = vtk . PointData ( vtk . Scalars ( self . output_data . a . tolist (), name = \"Pizeometric head\" )) cellData = vtk . CellData ( vtk . Scalars ( self . output_data . eff_flux , name = \"Effective flux\" ), vtk . Vectors ( fluxmatrix , \"Flux\" )) structure = vtk . PolyData ( points = points , polygons = polygons ) vtkData = vtk . VtkData ( structure , pointData , cellData ) vtkData . tofile ( path , \"ascii\" ) execute ( self ) Executes FEM solver routine for groundwater flow Source code in src\\flowmodel.py def execute ( self ): \"\"\"Executes FEM solver routine for groundwater flow\"\"\" print ( \"Solver is being executed...\" ) self . pg and self . pg . set ( 1 , \"Staring solver...\" ) # Above is a truncated if statement, \"arg and func\" = \"if arg: func\". # If pg is specified in the constructor it returns True, since all not # empty/zero objects return True in python. # Transfer input data to local references print ( \"Importing data...\" ) self . pg and self . pg . set ( 1 , \"Importing data...\" ) # Truncated \"if\" ep = self . input_data . ep p = self . input_data . p kx = self . input_data . kx ky = self . input_data . ky geometry = self . input_data . geometry () # Mesh generation print ( \"Generating mesh...\" ) self . pg and self . pg . set ( 3 , \"Generating mesh...\" ) el_type = 2 dof_per_node = 1 mesh = cfm . GmshMeshGenerator ( geometry ) mesh . el_size_factor = self . input_data . el_size_factor mesh . el_type = el_type mesh . dofs_per_node = dof_per_node mesh . return_boundary_elements = True coords , edof , dofs , bdofs , * _ = mesh . create () # Additional variables print ( \"Preparing additional variables...\" ) self . pg and self . pg . set ( 18 , \"Preparing additional variables...\" ) ndof = np . size ( dofs ) ex , ey = cfc . coordxtr ( edof , coords , dofs ) D = np . array ([[ kx , 0. ], [ 0. , ky ]]) # Stiffness matrix print ( \"Assembling stiffness matrix...\" ) self . pg and self . pg . set ( 20 , \"Assembling stiffness matrix...\" ) K = np . zeros ([ ndof , ndof ]) for elx , ely , eldof in zip ( ex , ey , edof ): Ke = cfc . flw2te ( elx , ely , ep , D ) cfc . assem ( eldof , K , Ke ) # Load vector print ( \"Assembling force vector...\" ) self . pg and self . pg . set ( 66 , \"Assembling force vector...\" ) f = np . zeros ([ ndof , 1 ]) # Boundary conditions print ( \"Assembling boundary conditions...\" ) self . pg and self . pg . set ( 67 , \"Assembling boundary conditions...\" ) bc = np . array ([], \"i\" ) bcVal = np . array ([], \"f\" ) bc , bcVal = cfu . applybc ( bdofs , bc , bcVal , 20 , 0.0 ) # Open side bc , bcVal = cfu . applybc ( bdofs , bc , bcVal , 30 , p ) # Dam side # Solve FEM-system print ( \"Solving equation system...\" ) self . pg and self . pg . set ( 70 , \"Solving equation system...\" ) a , r = cfc . solveq ( K , f , bc , bcVal ) # Extract element values print ( \"Computing element variables...\" ) self . pg and self . pg . set ( 80 , \"Computing element variables...\" ) ed = cfc . extract_eldisp ( edof , a ) qs , qt = cfc . flw2ts ( ex , ey , D , ed ) # Calculating effective flux print ( \"Calculating effective flux...\" ) self . pg and self . pg . set ( 97 , \"Calculating effective flux...\" ) eff_flux = [] for elqs in qs : eff_flux . append ( np . sqrt ( elqs [ 0 ] ** 2 + elqs [ 1 ] ** 2 )) # Transfer local references to output data print ( \"Exporting data...\" ) self . pg and self . pg . set ( 99 , \"Exporting data...\" ) self . output_data . geometry = geometry self . output_data . el_type = el_type self . output_data . dofs_per_node = dof_per_node self . output_data . coords = coords self . output_data . edof = edof self . output_data . dofs = dofs self . output_data . a = a self . output_data . r = r self . output_data . ed = ed self . output_data . qs = qs self . output_data . qt = qt self . output_data . eff_flux = eff_flux print ( \"Solver is done.\" ) self . pg and self . pg . set ( 100 , \"Solver is done.\" ) executeParamStudy ( self ) Executes parameter study and exports vtk-files Source code in src\\flowmodel.py def executeParamStudy ( self ): \"\"\"Executes parameter study and exports vtk-files\"\"\" old_d = self . input_data . d old_t = self . input_data . t if self . input_data . dStudy : dRange = np . linspace ( self . input_data . d , self . input_data . dEnd , self . input_data . steps ) self . output_data . range = dRange self . output_data . max_flux = np . zeros ( dRange . shape [ 0 ], float ) for i , d in enumerate ( dRange , 1 ): print ( f \"Executing for d = { d } ...\" ) value = int (( i - 1 ) / self . input_data . steps * 100 ) self . pg and self . pg . set ( value , f \"Executing for d = { d : .2f } ...\" ) self . input_data . d = float ( d ) solver = Solver ( self . input_data , self . output_data ) solver . execute () self . output_data . max_flux [ i - 1 ] = max ( self . output_data . eff_flux ) self . exportVtk ( f \" { self . basepath } _d { i : 03d } \" ) else : tRange = np . linspace ( self . input_data . t , self . input_data . tEnd , self . input_data . steps ) self . output_data . range = tRange self . output_data . max_flux = np . zeros ( tRange . shape [ 0 ], float ) for i , t in enumerate ( tRange , 1 ): print ( f \"Executing for t = { t } ...\" ) value = int (( i - 1 ) / self . input_data . steps * 100 ) self . pg and self . pg . set ( value , f \"Executing for t = { t : .2f } ...\" ) self . input_data . t = float ( t ) solver = Solver ( self . input_data , self . output_data ) solver . execute () self . output_data . max_flux [ i - 1 ] = max ( self . output_data . eff_flux ) self . exportVtk ( f \" { self . basepath } _t { i : 03d } \" ) self . input_data . d = old_d self . input_data . t = old_t print ( \"Parameter study is done.\" ) self . pg and self . pg . set ( 100 , \"Parameter study is done.\" ) exportVtk ( self , path ) Export results to VTK format Source code in src\\flowmodel.py def exportVtk ( self , path ): \"\"\"Export results to VTK format\"\"\" print ( f \"Exporting results to { path } . \\n \" ) # Expand variables to three dimensions fluxmatrix = ( np . c_ [ self . output_data . qs , np . zeros ( self . output_data . qs . shape [ 0 ])]) coordmatrix = ( np . c_ [ self . output_data . coords , np . zeros ( self . output_data . coords . shape [ 0 ])]) points = coordmatrix . tolist () polygons = ( self . output_data . edof - 1 ) . tolist () pointData = vtk . PointData ( vtk . Scalars ( self . output_data . a . tolist (), name = \"Pizeometric head\" )) cellData = vtk . CellData ( vtk . Scalars ( self . output_data . eff_flux , name = \"Effective flux\" ), vtk . Vectors ( fluxmatrix , \"Flux\" )) structure = vtk . PolyData ( points = points , polygons = polygons ) vtkData = vtk . VtkData ( structure , pointData , cellData ) vtkData . tofile ( path , \"ascii\" ) Visualization Class to visualize outdata as plots Attributes: Name Type Description input_data InputData Object containing input data output_data OutputData Object containing output data geomFig Figure Figure of geometry meshFig Figure Figure of mesh piezoFig Figure Figure of piezometric head reacFig Figure Figure of reaction flux effFig Figure Figure of effective flux paramFig Figure Figure of maximal effective flux geom_widget FigureCanvasQTAgg FigureCanvas of geometry mesh_widget FigureCanvasQTAgg FigureCanvas of mesh piezo_widget FigureCanvasQTAgg FigureCanvas of piezometric head reac_widget FigureCanvasQTAgg FigureCanvas of reaction flux eff_widget FigureCanvasQTAgg FigureCanvas of effective flux param_widget FigureCanvasQTAgg FigureCanvas of maximal effective flux Source code in src\\flowmodel.py class Visualization ( object ): \"\"\"Class to visualize outdata as plots Attributes: input_data (InputData): Object containing input data output_data (OutputData): Object containing output data geomFig (Figure): Figure of geometry meshFig (Figure): Figure of mesh piezoFig (Figure): Figure of piezometric head reacFig (Figure): Figure of reaction flux effFig (Figure): Figure of effective flux paramFig (Figure): Figure of maximal effective flux geom_widget (FigureCanvasQTAgg): FigureCanvas of geometry mesh_widget (FigureCanvasQTAgg): FigureCanvas of mesh piezo_widget (FigureCanvasQTAgg): FigureCanvas of piezometric head reac_widget (FigureCanvasQTAgg): FigureCanvas of reaction flux eff_widget (FigureCanvasQTAgg): FigureCanvas of effective flux param_widget (FigureCanvasQTAgg): FigureCanvas of maximal effective flux \"\"\" def __init__ ( self , input_data , output_data ): self . input_data = input_data self . output_data = output_data self . geomFig = None self . meshFig = None self . piezoFig = None self . reacFig = None self . effFig = None self . paramFig = None self . geom_widget = None self . mesh_widget = None self . piezo_widget = None self . reac_widget = None self . eff_widget = None self . param_widget = None def showAll ( self ): \"\"\"Plots multiple outdata\"\"\" geometry = self . output_data . geometry el_type = self . output_data . el_type dofs_per_node = self . output_data . dofs_per_node coords = self . output_data . coords edof = self . output_data . edof a = self . output_data . a r = self . output_data . r eff_flux = self . output_data . eff_flux # Geometry cfv . set_figure_dpi ( 100 ) cfv . figure ( fig_size = ( 10 , 3 )) cfv . draw_geometry ( geometry , title = \"Geometry\" ) # Mesh cfv . figure ( fig_size = ( 10 , 3 )) cfv . draw_mesh ( coords , edof , dofs_per_node , el_type , filled = True , title = \"Mesh\" ) # Piezometric head cfv . figure ( fig_size = ( 10 , 3 )) cfv . draw_nodal_values_shaded ( a , coords , edof , title = \"Piezometric head\" ) cfv . colorbar ( orientation = \"vertical\" , label = r \"Piezometric head $\\phi$ [m]\" ) # Reaction flux cfv . figure ( fig_size = ( 10 , 3 )) cfv . draw_nodal_values_shaded ( r , coords , edof , title = \"Reaction flux\" ) cfv . colorbar ( orientation = \"vertical\" , label = r \"Reaction flux $q$ [m$^2$/day]\" ) # Effective flux cfv . figure ( fig_size = ( 10 , 3 )) cfv . draw_element_values ( eff_flux , coords , edof , dofs_per_node , el_type , None , False , title = \"Effective flux\" ) cfv . colorbar ( orientation = \"vertical\" , label = r \"Effective flux $q_ {eff} $ [m$^2$/day]\" ) def showGeometry ( self , show = True ): \"\"\"Plots geometry Args: show (bool, optional): Flag if figures are drawn. Defaults to True. Returns: FigureCanvasQTAgg: Canvas of geometry (if show=False) \"\"\" if self . geomFig is None : self . geomFig = cfv . figure ( self . geomFig , show = show ) self . geom_widget = cfv . figure_widget ( self . geomFig , None ) cfv . clf () cfv . draw_geometry ( self . output_data . geometry , title = \"Geometry\" ) if show : self . wait () else : return self . geom_widget def showMesh ( self , show = True ): \"\"\"Plots mesh Args: show (bool, optional): Flag if figures are drawn. Defaults to True. Returns: FigureCanvasQTAgg: Canvas of mesh (if show=False) \"\"\" if self . meshFig is None : self . meshFig = cfv . figure ( self . meshFig , show = show ) self . mesh_widget = cfv . figure_widget ( self . meshFig , None ) cfv . clf () cfv . draw_mesh ( self . output_data . coords , self . output_data . edof , self . output_data . dofs_per_node , self . output_data . el_type , filled = True , title = \"Mesh\" ) if show : self . wait () else : return self . mesh_widget def showPiezo ( self , show = True ): \"\"\"Plots piezometric head Args: show (bool, optional): Flag if figures are drawn. Defaults to True. Returns: FigureCanvasQTAgg: Canvas of piezometric head (if show=False) \"\"\" if self . piezoFig is None : self . piezoFig = cfv . figure ( self . piezoFig , show = show ) self . piezo_widget = cfv . figure_widget ( self . piezoFig , None ) cfv . draw_nodal_values_shaded ( self . output_data . a , self . output_data . coords , self . output_data . edof , title = \"Piezometric head\" ) cfv . colorbar ( orientation = \"horizontal\" , label = r \"Piezometric head $\\phi$ [m]\" ) if show : self . wait () else : return self . piezo_widget def showReac ( self , show = True ): \"\"\"Plots reaction flux Args: show (bool, optional): Flag if figures are drawn. Defaults to True. Returns: FigureCanvasQTAgg: Canvas of reaction flux (if show=False) \"\"\" if self . reacFig is None : self . reacFig = cfv . figure ( self . reacFig , show = show ) self . reac_widget = cfv . figure_widget ( self . reacFig , None ) cfv . draw_nodal_values_shaded ( self . output_data . r , self . output_data . coords , self . output_data . edof , title = \"Reaction flux\" ) cfv . colorbar ( orientation = \"horizontal\" , label = r \"Reaction flux $q$ [m$^2$/day]\" ) if show : self . wait () else : return self . reac_widget def showEff ( self , show = True ): \"\"\"Plots effective flux Args: show (bool, optional): Flag if figures are drawn. Defaults to True. Returns: FigureCanvasQTAgg: Canvas of effective flux (if show=False) \"\"\" if self . effFig is None : self . effFig = cfv . figure ( self . effFig , show = show ) self . eff_widget = cfv . figure_widget ( self . effFig , None ) cfv . draw_element_values ( self . output_data . eff_flux , self . output_data . coords , self . output_data . edof , self . output_data . dofs_per_node , self . output_data . el_type , None , False , title = \"Effective flux\" ) cfv . colorbar ( orientation = \"horizontal\" , label = r \"Effective flux $q_ {eff} $ [m$^2$/day]\" ) if show : self . wait () else : return self . eff_widget def showParam ( self , show = True ): \"\"\"Plots maximal effective flux for parameter study Args: show (bool, optional): Flag if figures are drawn. Defaults to True. Returns: FigureCanvasQTAgg: Canvas of maximal effective flux for param-study (if show=False) \"\"\" if self . paramFig is None : self . paramFig = cfv . figure ( self . paramFig , show = show ) self . param_widget = cfv . figure_widget ( self . paramFig , None ) cfv . plt . plot ( self . output_data . range , self . output_data . max_flux , \"bo-\" ) cfv . plt . ylabel ( r \"Maximal flow $q_ {max} $ [m$^2$/day]\" ) if self . input_data . dStudy : cfv . plt . xlabel ( \"Depth d [m]\" ) cfv . plt . title ( \"Parameter study of depth\" ) else : cfv . plt . xlabel ( \"Thickness t [m]\" ) cfv . plt . title ( \"Parameter study of thickness\" ) if show : self . wait () else : return self . param_widget def closeAll ( self ): \"\"\"Closes all plots and remove attributes\"\"\" cfv . close_all () self . geomFig = None self . meshFig = None self . piezoFig = None self . reacFig = None self . effFig = None self . paramFig = None self . geom_widget = None self . mesh_widget = None self . piezo_widget = None self . reac_widget = None self . eff_widget = None self . param_widget = None def wait ( self ): \"\"\"Waits for plots to be closed\"\"\" cfv . show_and_wait () closeAll ( self ) Closes all plots and remove attributes Source code in src\\flowmodel.py def closeAll ( self ): \"\"\"Closes all plots and remove attributes\"\"\" cfv . close_all () self . geomFig = None self . meshFig = None self . piezoFig = None self . reacFig = None self . effFig = None self . paramFig = None self . geom_widget = None self . mesh_widget = None self . piezo_widget = None self . reac_widget = None self . eff_widget = None self . param_widget = None showAll ( self ) Plots multiple outdata Source code in src\\flowmodel.py def showAll ( self ): \"\"\"Plots multiple outdata\"\"\" geometry = self . output_data . geometry el_type = self . output_data . el_type dofs_per_node = self . output_data . dofs_per_node coords = self . output_data . coords edof = self . output_data . edof a = self . output_data . a r = self . output_data . r eff_flux = self . output_data . eff_flux # Geometry cfv . set_figure_dpi ( 100 ) cfv . figure ( fig_size = ( 10 , 3 )) cfv . draw_geometry ( geometry , title = \"Geometry\" ) # Mesh cfv . figure ( fig_size = ( 10 , 3 )) cfv . draw_mesh ( coords , edof , dofs_per_node , el_type , filled = True , title = \"Mesh\" ) # Piezometric head cfv . figure ( fig_size = ( 10 , 3 )) cfv . draw_nodal_values_shaded ( a , coords , edof , title = \"Piezometric head\" ) cfv . colorbar ( orientation = \"vertical\" , label = r \"Piezometric head $\\phi$ [m]\" ) # Reaction flux cfv . figure ( fig_size = ( 10 , 3 )) cfv . draw_nodal_values_shaded ( r , coords , edof , title = \"Reaction flux\" ) cfv . colorbar ( orientation = \"vertical\" , label = r \"Reaction flux $q$ [m$^2$/day]\" ) # Effective flux cfv . figure ( fig_size = ( 10 , 3 )) cfv . draw_element_values ( eff_flux , coords , edof , dofs_per_node , el_type , None , False , title = \"Effective flux\" ) cfv . colorbar ( orientation = \"vertical\" , label = r \"Effective flux $q_ {eff} $ [m$^2$/day]\" ) showEff ( self , show = True ) Plots effective flux Parameters: Name Type Description Default show bool Flag if figures are drawn. Defaults to True. True Returns: Type Description FigureCanvasQTAgg Canvas of effective flux (if show=False) Source code in src\\flowmodel.py def showEff ( self , show = True ): \"\"\"Plots effective flux Args: show (bool, optional): Flag if figures are drawn. Defaults to True. Returns: FigureCanvasQTAgg: Canvas of effective flux (if show=False) \"\"\" if self . effFig is None : self . effFig = cfv . figure ( self . effFig , show = show ) self . eff_widget = cfv . figure_widget ( self . effFig , None ) cfv . draw_element_values ( self . output_data . eff_flux , self . output_data . coords , self . output_data . edof , self . output_data . dofs_per_node , self . output_data . el_type , None , False , title = \"Effective flux\" ) cfv . colorbar ( orientation = \"horizontal\" , label = r \"Effective flux $q_ {eff} $ [m$^2$/day]\" ) if show : self . wait () else : return self . eff_widget showGeometry ( self , show = True ) Plots geometry Parameters: Name Type Description Default show bool Flag if figures are drawn. Defaults to True. True Returns: Type Description FigureCanvasQTAgg Canvas of geometry (if show=False) Source code in src\\flowmodel.py def showGeometry ( self , show = True ): \"\"\"Plots geometry Args: show (bool, optional): Flag if figures are drawn. Defaults to True. Returns: FigureCanvasQTAgg: Canvas of geometry (if show=False) \"\"\" if self . geomFig is None : self . geomFig = cfv . figure ( self . geomFig , show = show ) self . geom_widget = cfv . figure_widget ( self . geomFig , None ) cfv . clf () cfv . draw_geometry ( self . output_data . geometry , title = \"Geometry\" ) if show : self . wait () else : return self . geom_widget showMesh ( self , show = True ) Plots mesh Parameters: Name Type Description Default show bool Flag if figures are drawn. Defaults to True. True Returns: Type Description FigureCanvasQTAgg Canvas of mesh (if show=False) Source code in src\\flowmodel.py def showMesh ( self , show = True ): \"\"\"Plots mesh Args: show (bool, optional): Flag if figures are drawn. Defaults to True. Returns: FigureCanvasQTAgg: Canvas of mesh (if show=False) \"\"\" if self . meshFig is None : self . meshFig = cfv . figure ( self . meshFig , show = show ) self . mesh_widget = cfv . figure_widget ( self . meshFig , None ) cfv . clf () cfv . draw_mesh ( self . output_data . coords , self . output_data . edof , self . output_data . dofs_per_node , self . output_data . el_type , filled = True , title = \"Mesh\" ) if show : self . wait () else : return self . mesh_widget showParam ( self , show = True ) Plots maximal effective flux for parameter study Parameters: Name Type Description Default show bool Flag if figures are drawn. Defaults to True. True Returns: Type Description FigureCanvasQTAgg Canvas of maximal effective flux for param-study (if show=False) Source code in src\\flowmodel.py def showParam ( self , show = True ): \"\"\"Plots maximal effective flux for parameter study Args: show (bool, optional): Flag if figures are drawn. Defaults to True. Returns: FigureCanvasQTAgg: Canvas of maximal effective flux for param-study (if show=False) \"\"\" if self . paramFig is None : self . paramFig = cfv . figure ( self . paramFig , show = show ) self . param_widget = cfv . figure_widget ( self . paramFig , None ) cfv . plt . plot ( self . output_data . range , self . output_data . max_flux , \"bo-\" ) cfv . plt . ylabel ( r \"Maximal flow $q_ {max} $ [m$^2$/day]\" ) if self . input_data . dStudy : cfv . plt . xlabel ( \"Depth d [m]\" ) cfv . plt . title ( \"Parameter study of depth\" ) else : cfv . plt . xlabel ( \"Thickness t [m]\" ) cfv . plt . title ( \"Parameter study of thickness\" ) if show : self . wait () else : return self . param_widget showPiezo ( self , show = True ) Plots piezometric head Parameters: Name Type Description Default show bool Flag if figures are drawn. Defaults to True. True Returns: Type Description FigureCanvasQTAgg Canvas of piezometric head (if show=False) Source code in src\\flowmodel.py def showPiezo ( self , show = True ): \"\"\"Plots piezometric head Args: show (bool, optional): Flag if figures are drawn. Defaults to True. Returns: FigureCanvasQTAgg: Canvas of piezometric head (if show=False) \"\"\" if self . piezoFig is None : self . piezoFig = cfv . figure ( self . piezoFig , show = show ) self . piezo_widget = cfv . figure_widget ( self . piezoFig , None ) cfv . draw_nodal_values_shaded ( self . output_data . a , self . output_data . coords , self . output_data . edof , title = \"Piezometric head\" ) cfv . colorbar ( orientation = \"horizontal\" , label = r \"Piezometric head $\\phi$ [m]\" ) if show : self . wait () else : return self . piezo_widget showReac ( self , show = True ) Plots reaction flux Parameters: Name Type Description Default show bool Flag if figures are drawn. Defaults to True. True Returns: Type Description FigureCanvasQTAgg Canvas of reaction flux (if show=False) Source code in src\\flowmodel.py def showReac ( self , show = True ): \"\"\"Plots reaction flux Args: show (bool, optional): Flag if figures are drawn. Defaults to True. Returns: FigureCanvasQTAgg: Canvas of reaction flux (if show=False) \"\"\" if self . reacFig is None : self . reacFig = cfv . figure ( self . reacFig , show = show ) self . reac_widget = cfv . figure_widget ( self . reacFig , None ) cfv . draw_nodal_values_shaded ( self . output_data . r , self . output_data . coords , self . output_data . edof , title = \"Reaction flux\" ) cfv . colorbar ( orientation = \"horizontal\" , label = r \"Reaction flux $q$ [m$^2$/day]\" ) if show : self . wait () else : return self . reac_widget wait ( self ) Waits for plots to be closed Source code in src\\flowmodel.py def wait ( self ): \"\"\"Waits for plots to be closed\"\"\" cfv . show_and_wait ()","title":"Flowmodel"},{"location":"flowmodel/#code-reference-flowmodelpy","text":"Groundwater Flow Model This module contains a collection of five classes with combined functionality to construct a program for finite element analysis of groundwater flow.","title":"Code Reference flowmodel.py"},{"location":"flowmodel/#src.flowmodel.InputData","text":"Class to define geometry and manage indata for the model Attributes: Name Type Description version int Version corresponding to worksheet number w float Width of ground h float Height of ground d float Depth of dividing wall (initial if parameter study) t float Thickness of dividing wall (initial if parameter study) p float Pressure head on left side of dividing wall kx float Permeability coefficient in x-direction ky float Permeability coefficient in y-direction ep list Element thickness (calfem) el_size_factor float Maximal element size dStudy bool Flag if d is studied, otherwise t dEnd float End depth in study of d tEnd float End thickness in study of t steps int Amount of steps of parameter study Source code in src\\flowmodel.py class InputData ( object ): \"\"\"Class to define geometry and manage indata for the model Attributes: version (int): Version corresponding to worksheet number w (float): Width of ground h (float): Height of ground d (float): Depth of dividing wall (initial if parameter study) t (float): Thickness of dividing wall (initial if parameter study) p (float): Pressure head on left side of dividing wall kx (float): Permeability coefficient in x-direction ky (float): Permeability coefficient in y-direction ep (list): Element thickness (calfem) el_size_factor (float): Maximal element size dStudy (bool): Flag if d is studied, otherwise t dEnd (float): End depth in study of d tEnd (float): End thickness in study of t steps (int): Amount of steps of parameter study \"\"\" def __init__ ( self ): # Standard model self . version = 7 self . w = 50. self . h = 10. self . d = 2. self . t = 1. self . p = 10. self . kx = 20.0 self . ky = 20.0 self . ep = [ 1.0 ] self . el_size_factor = 1 # Parameter study self . dStudy = True self . dEnd = 8. self . tEnd = 10. self . steps = 10 def save ( self , path ): \"\"\"Saves indata to a .json file Args: path (str): Path (dir + name) to write to Returns: bool: True for success, False otherwise. \"\"\" input_data = {} input_data [ \"version\" ] = self . version input_data [ \"w\" ] = self . w input_data [ \"h\" ] = self . h input_data [ \"d\" ] = self . d input_data [ \"t\" ] = self . t input_data [ \"p\" ] = self . p input_data [ \"kx\" ] = self . kx input_data [ \"ky\" ] = self . ky input_data [ \"ep\" ] = self . ep input_data [ \"el_size_factor\" ] = self . el_size_factor input_data [ \"dStudy\" ] = self . dStudy input_data [ \"dEnd\" ] = self . dEnd input_data [ \"tEnd\" ] = self . tEnd input_data [ \"steps\" ] = self . steps try : with open ( path , \"w\" ) as ofile : json . dump ( input_data , ofile , sort_keys = True , indent = 4 ) return True except Exception : print ( f \"The file { path } could not be written.\" ) return False def load ( self , path ): \"\"\"Reads indata from a .json file Args: path (str): Path to read from Returns: bool: True for success, False otherwise. \"\"\" try : with open ( path , \"r\" ) as ifile : input_data = json . load ( ifile ) except Exception : print ( f \"The file { path } could not be found or read.\" ) return False if input_data [ \"version\" ] != self . version : print ( f \"The file { path } is from different version, \" \"loading was canceled.\" ) return False self . w = input_data [ \"w\" ] self . h = input_data [ \"h\" ] self . d = input_data [ \"d\" ] self . t = input_data [ \"t\" ] self . p = input_data [ \"p\" ] self . kx = input_data [ \"kx\" ] self . ky = input_data [ \"ky\" ] self . ep = input_data [ \"ep\" ] self . el_size_factor = input_data [ \"el_size_factor\" ] self . dStudy = input_data [ \"dStudy\" ] self . dEnd = input_data [ \"dEnd\" ] self . tEnd = input_data [ \"tEnd\" ] self . steps = input_data [ \"steps\" ] return True def geometry ( self ): \"\"\"Defines problem geometry Returns: Geometry: Object containing geometric data \"\"\" g = cfg . Geometry () w = self . w h = self . h t = self . t d = self . d # Points g . point ([ 0. , 0. ]) # 0 g . point ([ w , 0. ]) # 1 g . point ([ w , h ]) # 2 g . point ([( w + t ) / 2. , h ]) # 3 g . point ([( w + t ) / 2. , h - d ]) # 4 g . point ([( w - t ) / 2. , h - d ]) # 5 g . point ([( w - t ) / 2. , h ]) # 6 g . point ([ 0. , h ]) # 7 # Lines g . spline ([ 0 , 1 ]) # 0 g . spline ([ 1 , 2 ]) # 1 g . spline ([ 2 , 3 ], marker = 20 ) # 2 Open side g . spline ([ 3 , 4 ]) # 3 g . spline ([ 4 , 5 ]) # 4 g . spline ([ 5 , 6 ]) # 5 g . spline ([ 6 , 7 ], marker = 30 ) # 6 Dam side g . spline ([ 7 , 0 ]) # 7 g . surface ([ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ]) return g def validModel ( self ): \"\"\"Verifies valid model parameters A model is Valid if {w,h,d,t,p,kx,ky} > 0, w > t and h > d. Returns: bool: True if valid, false otherwise. \"\"\" notneg = [ self . w , self . h , self . d , self . t , self . p , self . kx , self . ky ] if self . w > self . t and self . h > self . d and all ( i > 0 for i in notneg ): return True return False def validParam ( self ): \"\"\"Verifies valid parameter study parameters A parameter study is valid if h > d_end > d for a study of d w > t_end > t for a study of t Returns: bool: True if valid, false otherwise. \"\"\" if self . dStudy and self . h > self . dEnd > self . d : return True elif self . w > self . tEnd > self . t : return True return False","title":"InputData"},{"location":"flowmodel/#src.flowmodel.InputData.geometry","text":"Defines problem geometry Returns: Type Description Geometry Object containing geometric data Source code in src\\flowmodel.py def geometry ( self ): \"\"\"Defines problem geometry Returns: Geometry: Object containing geometric data \"\"\" g = cfg . Geometry () w = self . w h = self . h t = self . t d = self . d # Points g . point ([ 0. , 0. ]) # 0 g . point ([ w , 0. ]) # 1 g . point ([ w , h ]) # 2 g . point ([( w + t ) / 2. , h ]) # 3 g . point ([( w + t ) / 2. , h - d ]) # 4 g . point ([( w - t ) / 2. , h - d ]) # 5 g . point ([( w - t ) / 2. , h ]) # 6 g . point ([ 0. , h ]) # 7 # Lines g . spline ([ 0 , 1 ]) # 0 g . spline ([ 1 , 2 ]) # 1 g . spline ([ 2 , 3 ], marker = 20 ) # 2 Open side g . spline ([ 3 , 4 ]) # 3 g . spline ([ 4 , 5 ]) # 4 g . spline ([ 5 , 6 ]) # 5 g . spline ([ 6 , 7 ], marker = 30 ) # 6 Dam side g . spline ([ 7 , 0 ]) # 7 g . surface ([ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ]) return g","title":"geometry()"},{"location":"flowmodel/#src.flowmodel.InputData.load","text":"Reads indata from a .json file Parameters: Name Type Description Default path str Path to read from required Returns: Type Description bool True for success, False otherwise. Source code in src\\flowmodel.py def load ( self , path ): \"\"\"Reads indata from a .json file Args: path (str): Path to read from Returns: bool: True for success, False otherwise. \"\"\" try : with open ( path , \"r\" ) as ifile : input_data = json . load ( ifile ) except Exception : print ( f \"The file { path } could not be found or read.\" ) return False if input_data [ \"version\" ] != self . version : print ( f \"The file { path } is from different version, \" \"loading was canceled.\" ) return False self . w = input_data [ \"w\" ] self . h = input_data [ \"h\" ] self . d = input_data [ \"d\" ] self . t = input_data [ \"t\" ] self . p = input_data [ \"p\" ] self . kx = input_data [ \"kx\" ] self . ky = input_data [ \"ky\" ] self . ep = input_data [ \"ep\" ] self . el_size_factor = input_data [ \"el_size_factor\" ] self . dStudy = input_data [ \"dStudy\" ] self . dEnd = input_data [ \"dEnd\" ] self . tEnd = input_data [ \"tEnd\" ] self . steps = input_data [ \"steps\" ] return True","title":"load()"},{"location":"flowmodel/#src.flowmodel.InputData.save","text":"Saves indata to a .json file Parameters: Name Type Description Default path str Path (dir + name) to write to required Returns: Type Description bool True for success, False otherwise. Source code in src\\flowmodel.py def save ( self , path ): \"\"\"Saves indata to a .json file Args: path (str): Path (dir + name) to write to Returns: bool: True for success, False otherwise. \"\"\" input_data = {} input_data [ \"version\" ] = self . version input_data [ \"w\" ] = self . w input_data [ \"h\" ] = self . h input_data [ \"d\" ] = self . d input_data [ \"t\" ] = self . t input_data [ \"p\" ] = self . p input_data [ \"kx\" ] = self . kx input_data [ \"ky\" ] = self . ky input_data [ \"ep\" ] = self . ep input_data [ \"el_size_factor\" ] = self . el_size_factor input_data [ \"dStudy\" ] = self . dStudy input_data [ \"dEnd\" ] = self . dEnd input_data [ \"tEnd\" ] = self . tEnd input_data [ \"steps\" ] = self . steps try : with open ( path , \"w\" ) as ofile : json . dump ( input_data , ofile , sort_keys = True , indent = 4 ) return True except Exception : print ( f \"The file { path } could not be written.\" ) return False","title":"save()"},{"location":"flowmodel/#src.flowmodel.InputData.validModel","text":"Verifies valid model parameters A model is Valid if {w,h,d,t,p,kx,ky} > 0, w > t and h > d. Returns: Type Description bool True if valid, false otherwise. Source code in src\\flowmodel.py def validModel ( self ): \"\"\"Verifies valid model parameters A model is Valid if {w,h,d,t,p,kx,ky} > 0, w > t and h > d. Returns: bool: True if valid, false otherwise. \"\"\" notneg = [ self . w , self . h , self . d , self . t , self . p , self . kx , self . ky ] if self . w > self . t and self . h > self . d and all ( i > 0 for i in notneg ): return True return False","title":"validModel()"},{"location":"flowmodel/#src.flowmodel.InputData.validParam","text":"Verifies valid parameter study parameters A parameter study is valid if h > d_end > d for a study of d w > t_end > t for a study of t Returns: Type Description bool True if valid, false otherwise. Source code in src\\flowmodel.py def validParam ( self ): \"\"\"Verifies valid parameter study parameters A parameter study is valid if h > d_end > d for a study of d w > t_end > t for a study of t Returns: bool: True if valid, false otherwise. \"\"\" if self . dStudy and self . h > self . dEnd > self . d : return True elif self . w > self . tEnd > self . t : return True return False","title":"validParam()"},{"location":"flowmodel/#src.flowmodel.OutputData","text":"Class to store the results from the calculation Attributes: Name Type Description geometry Geometry Geometric data object el_type int Element type (3-triangle) dof_per_node int Degrees of freedom per node coords array Global coordinate matrix edof array Element topology matrix dofs array Degrees of freedom matrix a array Nodal piezometric head r array Nodal reaction flux ed array Elemental piezometric head qs array Elemental volume flux qt array Elemental hydraulic gradient eff_flux array Elemental effective flux range array Range of parameter study max_flux array Maximum effective flux of parameter study Source code in src\\flowmodel.py class OutputData ( object ): \"\"\"Class to store the results from the calculation Attributes: geometry (Geometry): Geometric data object el_type (int): Element type (3-triangle) dof_per_node (int): Degrees of freedom per node coords (array): Global coordinate matrix edof (array): Element topology matrix dofs (array): Degrees of freedom matrix a (array): Nodal piezometric head r (array): Nodal reaction flux ed (array): Elemental piezometric head qs (array): Elemental volume flux qt (array): Elemental hydraulic gradient eff_flux (array): Elemental effective flux range (array): Range of parameter study max_flux (array): Maximum effective flux of parameter study \"\"\" def __init__ ( self ): # Geometry and FEM self . geometry = None self . el_type = None self . dof_per_node = None self . coords = None self . edof = None self . dofs = None # Results self . a = None self . r = None self . ed = None self . qs = None self . qt = None self . eff_flux = None # Parameter study self . range = None self . max_flux = None","title":"OutputData"},{"location":"flowmodel/#src.flowmodel.Report","text":"Class to present in-/outdata as a report Attributes: Name Type Description input_data InputData Object containing input data output_data OutputData Object containing output data report str String to print out as report Source code in src\\flowmodel.py class Report ( object ): \"\"\"Class to present in-/outdata as a report Attributes: input_data (InputData): Object containing input data output_data (OutputData): Object containing output data report (str): String to print out as report \"\"\" def __init__ ( self , input_data , output_data ): self . input_data = input_data self . output_data = output_data self . report = \"\" def clear ( self ): \"\"\"Clears report\"\"\" self . report = \"\" def add_text ( self , text = \"\" ): \"\"\"Adds a new line of text to report Args: text (str, optional): Text to add to report (defult is \"\") \"\"\" self . report += str ( text ) + \" \\n \" def __str__ ( self ): self . clear () # Banner s = f \"Report of Groundwater flow | Version { self . input_data . version } \" self . add_text ( f \" { '' : =^60 } \\n { s : ^60 } \\n { '' : =^60 } \" ) # Model input self . add_text () self . add_text ( f \" { ' Model input ' : ~^60 } \" ) self . add_text ( \"Element dimensions [m]\" ) self . add_text ( f \"w: { self . input_data . w } \" ) self . add_text ( f \"h: { self . input_data . h } \" ) self . add_text ( f \"d: { self . input_data . d } \" ) self . add_text ( f \"t: { self . input_data . t } \" ) self . add_text ( f \"p: { self . input_data . p } \" ) self . add_text () self . add_text ( \"Permeability [m/day]\" ) self . add_text ( f \"kx: { self . input_data . kx } \" ) self . add_text ( f \"ky: { self . input_data . ky } \" ) self . add_text () self . add_text ( \"Thickness [m]\" ) self . add_text ( f \"ep: { self . input_data . ep } \" ) self . add_text () self . add_text ( \"Maximum element size [-]\" ) self . add_text ( f \"el_size_factor: { self . input_data . el_size_factor } \" ) # Model output self . add_text () self . add_text ( f \" { ' Model Output ' : ~^60 } \" ) self . add_text ( \"Number of nodes [-]\" ) self . add_text ( f \"nnode: { self . output_data . coords . shape [ 0 ] } \" ) self . add_text () self . add_text ( \"Number of elements [-]\" ) self . add_text ( f \"nnode: { self . output_data . edof . shape [ 0 ] } \" ) self . add_text () self . add_text ( \"Maximal effective flux [m^2/day]\" ) self . add_text ( f \"Max eff_flux: { max ( self . output_data . eff_flux ) : .2f } \" ) # Per node data self . add_text () self . add_text ( \"Per Node\" ) table = tbl . tabulate ( { \" \\n Node\" : self . output_data . dofs , \"X-coord \\n [m]\" : self . output_data . coords [:, 0 ], \"Y-coord \\n [m]\" : self . output_data . coords [:, 1 ], \"Pizeometric \\n head [m]\" : self . output_data . a }, headers = \"keys\" , numalign = \"center\" , floatfmt = ( \".0f\" , \".2f\" , \".2f\" , \".2f\" ), tablefmt = \"simple\" , ) self . add_text ( table ) # Per element data self . add_text () self . add_text ( \"Per Element\" + \"{'[m^2/day]':>38}\" ) table = tbl . tabulate ( { \" \\n Elem\" : np . arange ( 1 , np . shape ( self . output_data . edof )[ 0 ] + 1 ), \"node \\n 1\" : self . output_data . edof [:, 0 ], \"node \\n 2\" : self . output_data . edof [:, 1 ], \"node \\n 3\" : self . output_data . edof [:, 2 ], \" \\n x \" : self . output_data . qs [:, 0 ], \"Flux \\n y \" : self . output_data . qs [:, 1 ], \" \\n eff \" : self . output_data . eff_flux }, headers = \"keys\" , numalign = \"center\" , floatfmt = ( \".0f\" , \".0f\" , \".0f\" , \".0f\" , \".2f\" , \".2f\" , \".2f\" , \".2f\" ), tablefmt = \"simple\" , ) self . add_text ( table ) self . add_text ( f \" { '' : =^60 } \" ) return self . report","title":"Report"},{"location":"flowmodel/#src.flowmodel.Report.add_text","text":"Adds a new line of text to report Parameters: Name Type Description Default text str Text to add to report (defult is \"\") '' Source code in src\\flowmodel.py def add_text ( self , text = \"\" ): \"\"\"Adds a new line of text to report Args: text (str, optional): Text to add to report (defult is \"\") \"\"\" self . report += str ( text ) + \" \\n \"","title":"add_text()"},{"location":"flowmodel/#src.flowmodel.Report.clear","text":"Clears report Source code in src\\flowmodel.py def clear ( self ): \"\"\"Clears report\"\"\" self . report = \"\"","title":"clear()"},{"location":"flowmodel/#src.flowmodel.Solver","text":"Class to handle in-/outdata with FEM solver Attributes: Name Type Description input_data InputData Object containing input data output_data OutputData Object containing output data basepath str Optional path for export to VTK pg Progress Optional progress-object to inform user of calculations Source code in src\\flowmodel.py class Solver ( object ): \"\"\"Class to handle in-/outdata with FEM solver Attributes: input_data (InputData): Object containing input data output_data (OutputData): Object containing output data basepath (str): Optional path for export to VTK pg (Progress): Optional progress-object to inform user of calculations \"\"\" def __init__ ( self , input_data , output_data , pg = False , basepath = \"\" ): self . input_data = input_data self . output_data = output_data self . pg = pg self . basepath = basepath def execute ( self ): \"\"\"Executes FEM solver routine for groundwater flow\"\"\" print ( \"Solver is being executed...\" ) self . pg and self . pg . set ( 1 , \"Staring solver...\" ) # Above is a truncated if statement, \"arg and func\" = \"if arg: func\". # If pg is specified in the constructor it returns True, since all not # empty/zero objects return True in python. # Transfer input data to local references print ( \"Importing data...\" ) self . pg and self . pg . set ( 1 , \"Importing data...\" ) # Truncated \"if\" ep = self . input_data . ep p = self . input_data . p kx = self . input_data . kx ky = self . input_data . ky geometry = self . input_data . geometry () # Mesh generation print ( \"Generating mesh...\" ) self . pg and self . pg . set ( 3 , \"Generating mesh...\" ) el_type = 2 dof_per_node = 1 mesh = cfm . GmshMeshGenerator ( geometry ) mesh . el_size_factor = self . input_data . el_size_factor mesh . el_type = el_type mesh . dofs_per_node = dof_per_node mesh . return_boundary_elements = True coords , edof , dofs , bdofs , * _ = mesh . create () # Additional variables print ( \"Preparing additional variables...\" ) self . pg and self . pg . set ( 18 , \"Preparing additional variables...\" ) ndof = np . size ( dofs ) ex , ey = cfc . coordxtr ( edof , coords , dofs ) D = np . array ([[ kx , 0. ], [ 0. , ky ]]) # Stiffness matrix print ( \"Assembling stiffness matrix...\" ) self . pg and self . pg . set ( 20 , \"Assembling stiffness matrix...\" ) K = np . zeros ([ ndof , ndof ]) for elx , ely , eldof in zip ( ex , ey , edof ): Ke = cfc . flw2te ( elx , ely , ep , D ) cfc . assem ( eldof , K , Ke ) # Load vector print ( \"Assembling force vector...\" ) self . pg and self . pg . set ( 66 , \"Assembling force vector...\" ) f = np . zeros ([ ndof , 1 ]) # Boundary conditions print ( \"Assembling boundary conditions...\" ) self . pg and self . pg . set ( 67 , \"Assembling boundary conditions...\" ) bc = np . array ([], \"i\" ) bcVal = np . array ([], \"f\" ) bc , bcVal = cfu . applybc ( bdofs , bc , bcVal , 20 , 0.0 ) # Open side bc , bcVal = cfu . applybc ( bdofs , bc , bcVal , 30 , p ) # Dam side # Solve FEM-system print ( \"Solving equation system...\" ) self . pg and self . pg . set ( 70 , \"Solving equation system...\" ) a , r = cfc . solveq ( K , f , bc , bcVal ) # Extract element values print ( \"Computing element variables...\" ) self . pg and self . pg . set ( 80 , \"Computing element variables...\" ) ed = cfc . extract_eldisp ( edof , a ) qs , qt = cfc . flw2ts ( ex , ey , D , ed ) # Calculating effective flux print ( \"Calculating effective flux...\" ) self . pg and self . pg . set ( 97 , \"Calculating effective flux...\" ) eff_flux = [] for elqs in qs : eff_flux . append ( np . sqrt ( elqs [ 0 ] ** 2 + elqs [ 1 ] ** 2 )) # Transfer local references to output data print ( \"Exporting data...\" ) self . pg and self . pg . set ( 99 , \"Exporting data...\" ) self . output_data . geometry = geometry self . output_data . el_type = el_type self . output_data . dofs_per_node = dof_per_node self . output_data . coords = coords self . output_data . edof = edof self . output_data . dofs = dofs self . output_data . a = a self . output_data . r = r self . output_data . ed = ed self . output_data . qs = qs self . output_data . qt = qt self . output_data . eff_flux = eff_flux print ( \"Solver is done.\" ) self . pg and self . pg . set ( 100 , \"Solver is done.\" ) def executeParamStudy ( self ): \"\"\"Executes parameter study and exports vtk-files\"\"\" old_d = self . input_data . d old_t = self . input_data . t if self . input_data . dStudy : dRange = np . linspace ( self . input_data . d , self . input_data . dEnd , self . input_data . steps ) self . output_data . range = dRange self . output_data . max_flux = np . zeros ( dRange . shape [ 0 ], float ) for i , d in enumerate ( dRange , 1 ): print ( f \"Executing for d = { d } ...\" ) value = int (( i - 1 ) / self . input_data . steps * 100 ) self . pg and self . pg . set ( value , f \"Executing for d = { d : .2f } ...\" ) self . input_data . d = float ( d ) solver = Solver ( self . input_data , self . output_data ) solver . execute () self . output_data . max_flux [ i - 1 ] = max ( self . output_data . eff_flux ) self . exportVtk ( f \" { self . basepath } _d { i : 03d } \" ) else : tRange = np . linspace ( self . input_data . t , self . input_data . tEnd , self . input_data . steps ) self . output_data . range = tRange self . output_data . max_flux = np . zeros ( tRange . shape [ 0 ], float ) for i , t in enumerate ( tRange , 1 ): print ( f \"Executing for t = { t } ...\" ) value = int (( i - 1 ) / self . input_data . steps * 100 ) self . pg and self . pg . set ( value , f \"Executing for t = { t : .2f } ...\" ) self . input_data . t = float ( t ) solver = Solver ( self . input_data , self . output_data ) solver . execute () self . output_data . max_flux [ i - 1 ] = max ( self . output_data . eff_flux ) self . exportVtk ( f \" { self . basepath } _t { i : 03d } \" ) self . input_data . d = old_d self . input_data . t = old_t print ( \"Parameter study is done.\" ) self . pg and self . pg . set ( 100 , \"Parameter study is done.\" ) def exportVtk ( self , path ): \"\"\"Export results to VTK format\"\"\" print ( f \"Exporting results to { path } . \\n \" ) # Expand variables to three dimensions fluxmatrix = ( np . c_ [ self . output_data . qs , np . zeros ( self . output_data . qs . shape [ 0 ])]) coordmatrix = ( np . c_ [ self . output_data . coords , np . zeros ( self . output_data . coords . shape [ 0 ])]) points = coordmatrix . tolist () polygons = ( self . output_data . edof - 1 ) . tolist () pointData = vtk . PointData ( vtk . Scalars ( self . output_data . a . tolist (), name = \"Pizeometric head\" )) cellData = vtk . CellData ( vtk . Scalars ( self . output_data . eff_flux , name = \"Effective flux\" ), vtk . Vectors ( fluxmatrix , \"Flux\" )) structure = vtk . PolyData ( points = points , polygons = polygons ) vtkData = vtk . VtkData ( structure , pointData , cellData ) vtkData . tofile ( path , \"ascii\" )","title":"Solver"},{"location":"flowmodel/#src.flowmodel.Solver.execute","text":"Executes FEM solver routine for groundwater flow Source code in src\\flowmodel.py def execute ( self ): \"\"\"Executes FEM solver routine for groundwater flow\"\"\" print ( \"Solver is being executed...\" ) self . pg and self . pg . set ( 1 , \"Staring solver...\" ) # Above is a truncated if statement, \"arg and func\" = \"if arg: func\". # If pg is specified in the constructor it returns True, since all not # empty/zero objects return True in python. # Transfer input data to local references print ( \"Importing data...\" ) self . pg and self . pg . set ( 1 , \"Importing data...\" ) # Truncated \"if\" ep = self . input_data . ep p = self . input_data . p kx = self . input_data . kx ky = self . input_data . ky geometry = self . input_data . geometry () # Mesh generation print ( \"Generating mesh...\" ) self . pg and self . pg . set ( 3 , \"Generating mesh...\" ) el_type = 2 dof_per_node = 1 mesh = cfm . GmshMeshGenerator ( geometry ) mesh . el_size_factor = self . input_data . el_size_factor mesh . el_type = el_type mesh . dofs_per_node = dof_per_node mesh . return_boundary_elements = True coords , edof , dofs , bdofs , * _ = mesh . create () # Additional variables print ( \"Preparing additional variables...\" ) self . pg and self . pg . set ( 18 , \"Preparing additional variables...\" ) ndof = np . size ( dofs ) ex , ey = cfc . coordxtr ( edof , coords , dofs ) D = np . array ([[ kx , 0. ], [ 0. , ky ]]) # Stiffness matrix print ( \"Assembling stiffness matrix...\" ) self . pg and self . pg . set ( 20 , \"Assembling stiffness matrix...\" ) K = np . zeros ([ ndof , ndof ]) for elx , ely , eldof in zip ( ex , ey , edof ): Ke = cfc . flw2te ( elx , ely , ep , D ) cfc . assem ( eldof , K , Ke ) # Load vector print ( \"Assembling force vector...\" ) self . pg and self . pg . set ( 66 , \"Assembling force vector...\" ) f = np . zeros ([ ndof , 1 ]) # Boundary conditions print ( \"Assembling boundary conditions...\" ) self . pg and self . pg . set ( 67 , \"Assembling boundary conditions...\" ) bc = np . array ([], \"i\" ) bcVal = np . array ([], \"f\" ) bc , bcVal = cfu . applybc ( bdofs , bc , bcVal , 20 , 0.0 ) # Open side bc , bcVal = cfu . applybc ( bdofs , bc , bcVal , 30 , p ) # Dam side # Solve FEM-system print ( \"Solving equation system...\" ) self . pg and self . pg . set ( 70 , \"Solving equation system...\" ) a , r = cfc . solveq ( K , f , bc , bcVal ) # Extract element values print ( \"Computing element variables...\" ) self . pg and self . pg . set ( 80 , \"Computing element variables...\" ) ed = cfc . extract_eldisp ( edof , a ) qs , qt = cfc . flw2ts ( ex , ey , D , ed ) # Calculating effective flux print ( \"Calculating effective flux...\" ) self . pg and self . pg . set ( 97 , \"Calculating effective flux...\" ) eff_flux = [] for elqs in qs : eff_flux . append ( np . sqrt ( elqs [ 0 ] ** 2 + elqs [ 1 ] ** 2 )) # Transfer local references to output data print ( \"Exporting data...\" ) self . pg and self . pg . set ( 99 , \"Exporting data...\" ) self . output_data . geometry = geometry self . output_data . el_type = el_type self . output_data . dofs_per_node = dof_per_node self . output_data . coords = coords self . output_data . edof = edof self . output_data . dofs = dofs self . output_data . a = a self . output_data . r = r self . output_data . ed = ed self . output_data . qs = qs self . output_data . qt = qt self . output_data . eff_flux = eff_flux print ( \"Solver is done.\" ) self . pg and self . pg . set ( 100 , \"Solver is done.\" )","title":"execute()"},{"location":"flowmodel/#src.flowmodel.Solver.executeParamStudy","text":"Executes parameter study and exports vtk-files Source code in src\\flowmodel.py def executeParamStudy ( self ): \"\"\"Executes parameter study and exports vtk-files\"\"\" old_d = self . input_data . d old_t = self . input_data . t if self . input_data . dStudy : dRange = np . linspace ( self . input_data . d , self . input_data . dEnd , self . input_data . steps ) self . output_data . range = dRange self . output_data . max_flux = np . zeros ( dRange . shape [ 0 ], float ) for i , d in enumerate ( dRange , 1 ): print ( f \"Executing for d = { d } ...\" ) value = int (( i - 1 ) / self . input_data . steps * 100 ) self . pg and self . pg . set ( value , f \"Executing for d = { d : .2f } ...\" ) self . input_data . d = float ( d ) solver = Solver ( self . input_data , self . output_data ) solver . execute () self . output_data . max_flux [ i - 1 ] = max ( self . output_data . eff_flux ) self . exportVtk ( f \" { self . basepath } _d { i : 03d } \" ) else : tRange = np . linspace ( self . input_data . t , self . input_data . tEnd , self . input_data . steps ) self . output_data . range = tRange self . output_data . max_flux = np . zeros ( tRange . shape [ 0 ], float ) for i , t in enumerate ( tRange , 1 ): print ( f \"Executing for t = { t } ...\" ) value = int (( i - 1 ) / self . input_data . steps * 100 ) self . pg and self . pg . set ( value , f \"Executing for t = { t : .2f } ...\" ) self . input_data . t = float ( t ) solver = Solver ( self . input_data , self . output_data ) solver . execute () self . output_data . max_flux [ i - 1 ] = max ( self . output_data . eff_flux ) self . exportVtk ( f \" { self . basepath } _t { i : 03d } \" ) self . input_data . d = old_d self . input_data . t = old_t print ( \"Parameter study is done.\" ) self . pg and self . pg . set ( 100 , \"Parameter study is done.\" )","title":"executeParamStudy()"},{"location":"flowmodel/#src.flowmodel.Solver.exportVtk","text":"Export results to VTK format Source code in src\\flowmodel.py def exportVtk ( self , path ): \"\"\"Export results to VTK format\"\"\" print ( f \"Exporting results to { path } . \\n \" ) # Expand variables to three dimensions fluxmatrix = ( np . c_ [ self . output_data . qs , np . zeros ( self . output_data . qs . shape [ 0 ])]) coordmatrix = ( np . c_ [ self . output_data . coords , np . zeros ( self . output_data . coords . shape [ 0 ])]) points = coordmatrix . tolist () polygons = ( self . output_data . edof - 1 ) . tolist () pointData = vtk . PointData ( vtk . Scalars ( self . output_data . a . tolist (), name = \"Pizeometric head\" )) cellData = vtk . CellData ( vtk . Scalars ( self . output_data . eff_flux , name = \"Effective flux\" ), vtk . Vectors ( fluxmatrix , \"Flux\" )) structure = vtk . PolyData ( points = points , polygons = polygons ) vtkData = vtk . VtkData ( structure , pointData , cellData ) vtkData . tofile ( path , \"ascii\" )","title":"exportVtk()"},{"location":"flowmodel/#src.flowmodel.Visualization","text":"Class to visualize outdata as plots Attributes: Name Type Description input_data InputData Object containing input data output_data OutputData Object containing output data geomFig Figure Figure of geometry meshFig Figure Figure of mesh piezoFig Figure Figure of piezometric head reacFig Figure Figure of reaction flux effFig Figure Figure of effective flux paramFig Figure Figure of maximal effective flux geom_widget FigureCanvasQTAgg FigureCanvas of geometry mesh_widget FigureCanvasQTAgg FigureCanvas of mesh piezo_widget FigureCanvasQTAgg FigureCanvas of piezometric head reac_widget FigureCanvasQTAgg FigureCanvas of reaction flux eff_widget FigureCanvasQTAgg FigureCanvas of effective flux param_widget FigureCanvasQTAgg FigureCanvas of maximal effective flux Source code in src\\flowmodel.py class Visualization ( object ): \"\"\"Class to visualize outdata as plots Attributes: input_data (InputData): Object containing input data output_data (OutputData): Object containing output data geomFig (Figure): Figure of geometry meshFig (Figure): Figure of mesh piezoFig (Figure): Figure of piezometric head reacFig (Figure): Figure of reaction flux effFig (Figure): Figure of effective flux paramFig (Figure): Figure of maximal effective flux geom_widget (FigureCanvasQTAgg): FigureCanvas of geometry mesh_widget (FigureCanvasQTAgg): FigureCanvas of mesh piezo_widget (FigureCanvasQTAgg): FigureCanvas of piezometric head reac_widget (FigureCanvasQTAgg): FigureCanvas of reaction flux eff_widget (FigureCanvasQTAgg): FigureCanvas of effective flux param_widget (FigureCanvasQTAgg): FigureCanvas of maximal effective flux \"\"\" def __init__ ( self , input_data , output_data ): self . input_data = input_data self . output_data = output_data self . geomFig = None self . meshFig = None self . piezoFig = None self . reacFig = None self . effFig = None self . paramFig = None self . geom_widget = None self . mesh_widget = None self . piezo_widget = None self . reac_widget = None self . eff_widget = None self . param_widget = None def showAll ( self ): \"\"\"Plots multiple outdata\"\"\" geometry = self . output_data . geometry el_type = self . output_data . el_type dofs_per_node = self . output_data . dofs_per_node coords = self . output_data . coords edof = self . output_data . edof a = self . output_data . a r = self . output_data . r eff_flux = self . output_data . eff_flux # Geometry cfv . set_figure_dpi ( 100 ) cfv . figure ( fig_size = ( 10 , 3 )) cfv . draw_geometry ( geometry , title = \"Geometry\" ) # Mesh cfv . figure ( fig_size = ( 10 , 3 )) cfv . draw_mesh ( coords , edof , dofs_per_node , el_type , filled = True , title = \"Mesh\" ) # Piezometric head cfv . figure ( fig_size = ( 10 , 3 )) cfv . draw_nodal_values_shaded ( a , coords , edof , title = \"Piezometric head\" ) cfv . colorbar ( orientation = \"vertical\" , label = r \"Piezometric head $\\phi$ [m]\" ) # Reaction flux cfv . figure ( fig_size = ( 10 , 3 )) cfv . draw_nodal_values_shaded ( r , coords , edof , title = \"Reaction flux\" ) cfv . colorbar ( orientation = \"vertical\" , label = r \"Reaction flux $q$ [m$^2$/day]\" ) # Effective flux cfv . figure ( fig_size = ( 10 , 3 )) cfv . draw_element_values ( eff_flux , coords , edof , dofs_per_node , el_type , None , False , title = \"Effective flux\" ) cfv . colorbar ( orientation = \"vertical\" , label = r \"Effective flux $q_ {eff} $ [m$^2$/day]\" ) def showGeometry ( self , show = True ): \"\"\"Plots geometry Args: show (bool, optional): Flag if figures are drawn. Defaults to True. Returns: FigureCanvasQTAgg: Canvas of geometry (if show=False) \"\"\" if self . geomFig is None : self . geomFig = cfv . figure ( self . geomFig , show = show ) self . geom_widget = cfv . figure_widget ( self . geomFig , None ) cfv . clf () cfv . draw_geometry ( self . output_data . geometry , title = \"Geometry\" ) if show : self . wait () else : return self . geom_widget def showMesh ( self , show = True ): \"\"\"Plots mesh Args: show (bool, optional): Flag if figures are drawn. Defaults to True. Returns: FigureCanvasQTAgg: Canvas of mesh (if show=False) \"\"\" if self . meshFig is None : self . meshFig = cfv . figure ( self . meshFig , show = show ) self . mesh_widget = cfv . figure_widget ( self . meshFig , None ) cfv . clf () cfv . draw_mesh ( self . output_data . coords , self . output_data . edof , self . output_data . dofs_per_node , self . output_data . el_type , filled = True , title = \"Mesh\" ) if show : self . wait () else : return self . mesh_widget def showPiezo ( self , show = True ): \"\"\"Plots piezometric head Args: show (bool, optional): Flag if figures are drawn. Defaults to True. Returns: FigureCanvasQTAgg: Canvas of piezometric head (if show=False) \"\"\" if self . piezoFig is None : self . piezoFig = cfv . figure ( self . piezoFig , show = show ) self . piezo_widget = cfv . figure_widget ( self . piezoFig , None ) cfv . draw_nodal_values_shaded ( self . output_data . a , self . output_data . coords , self . output_data . edof , title = \"Piezometric head\" ) cfv . colorbar ( orientation = \"horizontal\" , label = r \"Piezometric head $\\phi$ [m]\" ) if show : self . wait () else : return self . piezo_widget def showReac ( self , show = True ): \"\"\"Plots reaction flux Args: show (bool, optional): Flag if figures are drawn. Defaults to True. Returns: FigureCanvasQTAgg: Canvas of reaction flux (if show=False) \"\"\" if self . reacFig is None : self . reacFig = cfv . figure ( self . reacFig , show = show ) self . reac_widget = cfv . figure_widget ( self . reacFig , None ) cfv . draw_nodal_values_shaded ( self . output_data . r , self . output_data . coords , self . output_data . edof , title = \"Reaction flux\" ) cfv . colorbar ( orientation = \"horizontal\" , label = r \"Reaction flux $q$ [m$^2$/day]\" ) if show : self . wait () else : return self . reac_widget def showEff ( self , show = True ): \"\"\"Plots effective flux Args: show (bool, optional): Flag if figures are drawn. Defaults to True. Returns: FigureCanvasQTAgg: Canvas of effective flux (if show=False) \"\"\" if self . effFig is None : self . effFig = cfv . figure ( self . effFig , show = show ) self . eff_widget = cfv . figure_widget ( self . effFig , None ) cfv . draw_element_values ( self . output_data . eff_flux , self . output_data . coords , self . output_data . edof , self . output_data . dofs_per_node , self . output_data . el_type , None , False , title = \"Effective flux\" ) cfv . colorbar ( orientation = \"horizontal\" , label = r \"Effective flux $q_ {eff} $ [m$^2$/day]\" ) if show : self . wait () else : return self . eff_widget def showParam ( self , show = True ): \"\"\"Plots maximal effective flux for parameter study Args: show (bool, optional): Flag if figures are drawn. Defaults to True. Returns: FigureCanvasQTAgg: Canvas of maximal effective flux for param-study (if show=False) \"\"\" if self . paramFig is None : self . paramFig = cfv . figure ( self . paramFig , show = show ) self . param_widget = cfv . figure_widget ( self . paramFig , None ) cfv . plt . plot ( self . output_data . range , self . output_data . max_flux , \"bo-\" ) cfv . plt . ylabel ( r \"Maximal flow $q_ {max} $ [m$^2$/day]\" ) if self . input_data . dStudy : cfv . plt . xlabel ( \"Depth d [m]\" ) cfv . plt . title ( \"Parameter study of depth\" ) else : cfv . plt . xlabel ( \"Thickness t [m]\" ) cfv . plt . title ( \"Parameter study of thickness\" ) if show : self . wait () else : return self . param_widget def closeAll ( self ): \"\"\"Closes all plots and remove attributes\"\"\" cfv . close_all () self . geomFig = None self . meshFig = None self . piezoFig = None self . reacFig = None self . effFig = None self . paramFig = None self . geom_widget = None self . mesh_widget = None self . piezo_widget = None self . reac_widget = None self . eff_widget = None self . param_widget = None def wait ( self ): \"\"\"Waits for plots to be closed\"\"\" cfv . show_and_wait ()","title":"Visualization"},{"location":"flowmodel/#src.flowmodel.Visualization.closeAll","text":"Closes all plots and remove attributes Source code in src\\flowmodel.py def closeAll ( self ): \"\"\"Closes all plots and remove attributes\"\"\" cfv . close_all () self . geomFig = None self . meshFig = None self . piezoFig = None self . reacFig = None self . effFig = None self . paramFig = None self . geom_widget = None self . mesh_widget = None self . piezo_widget = None self . reac_widget = None self . eff_widget = None self . param_widget = None","title":"closeAll()"},{"location":"flowmodel/#src.flowmodel.Visualization.showAll","text":"Plots multiple outdata Source code in src\\flowmodel.py def showAll ( self ): \"\"\"Plots multiple outdata\"\"\" geometry = self . output_data . geometry el_type = self . output_data . el_type dofs_per_node = self . output_data . dofs_per_node coords = self . output_data . coords edof = self . output_data . edof a = self . output_data . a r = self . output_data . r eff_flux = self . output_data . eff_flux # Geometry cfv . set_figure_dpi ( 100 ) cfv . figure ( fig_size = ( 10 , 3 )) cfv . draw_geometry ( geometry , title = \"Geometry\" ) # Mesh cfv . figure ( fig_size = ( 10 , 3 )) cfv . draw_mesh ( coords , edof , dofs_per_node , el_type , filled = True , title = \"Mesh\" ) # Piezometric head cfv . figure ( fig_size = ( 10 , 3 )) cfv . draw_nodal_values_shaded ( a , coords , edof , title = \"Piezometric head\" ) cfv . colorbar ( orientation = \"vertical\" , label = r \"Piezometric head $\\phi$ [m]\" ) # Reaction flux cfv . figure ( fig_size = ( 10 , 3 )) cfv . draw_nodal_values_shaded ( r , coords , edof , title = \"Reaction flux\" ) cfv . colorbar ( orientation = \"vertical\" , label = r \"Reaction flux $q$ [m$^2$/day]\" ) # Effective flux cfv . figure ( fig_size = ( 10 , 3 )) cfv . draw_element_values ( eff_flux , coords , edof , dofs_per_node , el_type , None , False , title = \"Effective flux\" ) cfv . colorbar ( orientation = \"vertical\" , label = r \"Effective flux $q_ {eff} $ [m$^2$/day]\" )","title":"showAll()"},{"location":"flowmodel/#src.flowmodel.Visualization.showEff","text":"Plots effective flux Parameters: Name Type Description Default show bool Flag if figures are drawn. Defaults to True. True Returns: Type Description FigureCanvasQTAgg Canvas of effective flux (if show=False) Source code in src\\flowmodel.py def showEff ( self , show = True ): \"\"\"Plots effective flux Args: show (bool, optional): Flag if figures are drawn. Defaults to True. Returns: FigureCanvasQTAgg: Canvas of effective flux (if show=False) \"\"\" if self . effFig is None : self . effFig = cfv . figure ( self . effFig , show = show ) self . eff_widget = cfv . figure_widget ( self . effFig , None ) cfv . draw_element_values ( self . output_data . eff_flux , self . output_data . coords , self . output_data . edof , self . output_data . dofs_per_node , self . output_data . el_type , None , False , title = \"Effective flux\" ) cfv . colorbar ( orientation = \"horizontal\" , label = r \"Effective flux $q_ {eff} $ [m$^2$/day]\" ) if show : self . wait () else : return self . eff_widget","title":"showEff()"},{"location":"flowmodel/#src.flowmodel.Visualization.showGeometry","text":"Plots geometry Parameters: Name Type Description Default show bool Flag if figures are drawn. Defaults to True. True Returns: Type Description FigureCanvasQTAgg Canvas of geometry (if show=False) Source code in src\\flowmodel.py def showGeometry ( self , show = True ): \"\"\"Plots geometry Args: show (bool, optional): Flag if figures are drawn. Defaults to True. Returns: FigureCanvasQTAgg: Canvas of geometry (if show=False) \"\"\" if self . geomFig is None : self . geomFig = cfv . figure ( self . geomFig , show = show ) self . geom_widget = cfv . figure_widget ( self . geomFig , None ) cfv . clf () cfv . draw_geometry ( self . output_data . geometry , title = \"Geometry\" ) if show : self . wait () else : return self . geom_widget","title":"showGeometry()"},{"location":"flowmodel/#src.flowmodel.Visualization.showMesh","text":"Plots mesh Parameters: Name Type Description Default show bool Flag if figures are drawn. Defaults to True. True Returns: Type Description FigureCanvasQTAgg Canvas of mesh (if show=False) Source code in src\\flowmodel.py def showMesh ( self , show = True ): \"\"\"Plots mesh Args: show (bool, optional): Flag if figures are drawn. Defaults to True. Returns: FigureCanvasQTAgg: Canvas of mesh (if show=False) \"\"\" if self . meshFig is None : self . meshFig = cfv . figure ( self . meshFig , show = show ) self . mesh_widget = cfv . figure_widget ( self . meshFig , None ) cfv . clf () cfv . draw_mesh ( self . output_data . coords , self . output_data . edof , self . output_data . dofs_per_node , self . output_data . el_type , filled = True , title = \"Mesh\" ) if show : self . wait () else : return self . mesh_widget","title":"showMesh()"},{"location":"flowmodel/#src.flowmodel.Visualization.showParam","text":"Plots maximal effective flux for parameter study Parameters: Name Type Description Default show bool Flag if figures are drawn. Defaults to True. True Returns: Type Description FigureCanvasQTAgg Canvas of maximal effective flux for param-study (if show=False) Source code in src\\flowmodel.py def showParam ( self , show = True ): \"\"\"Plots maximal effective flux for parameter study Args: show (bool, optional): Flag if figures are drawn. Defaults to True. Returns: FigureCanvasQTAgg: Canvas of maximal effective flux for param-study (if show=False) \"\"\" if self . paramFig is None : self . paramFig = cfv . figure ( self . paramFig , show = show ) self . param_widget = cfv . figure_widget ( self . paramFig , None ) cfv . plt . plot ( self . output_data . range , self . output_data . max_flux , \"bo-\" ) cfv . plt . ylabel ( r \"Maximal flow $q_ {max} $ [m$^2$/day]\" ) if self . input_data . dStudy : cfv . plt . xlabel ( \"Depth d [m]\" ) cfv . plt . title ( \"Parameter study of depth\" ) else : cfv . plt . xlabel ( \"Thickness t [m]\" ) cfv . plt . title ( \"Parameter study of thickness\" ) if show : self . wait () else : return self . param_widget","title":"showParam()"},{"location":"flowmodel/#src.flowmodel.Visualization.showPiezo","text":"Plots piezometric head Parameters: Name Type Description Default show bool Flag if figures are drawn. Defaults to True. True Returns: Type Description FigureCanvasQTAgg Canvas of piezometric head (if show=False) Source code in src\\flowmodel.py def showPiezo ( self , show = True ): \"\"\"Plots piezometric head Args: show (bool, optional): Flag if figures are drawn. Defaults to True. Returns: FigureCanvasQTAgg: Canvas of piezometric head (if show=False) \"\"\" if self . piezoFig is None : self . piezoFig = cfv . figure ( self . piezoFig , show = show ) self . piezo_widget = cfv . figure_widget ( self . piezoFig , None ) cfv . draw_nodal_values_shaded ( self . output_data . a , self . output_data . coords , self . output_data . edof , title = \"Piezometric head\" ) cfv . colorbar ( orientation = \"horizontal\" , label = r \"Piezometric head $\\phi$ [m]\" ) if show : self . wait () else : return self . piezo_widget","title":"showPiezo()"},{"location":"flowmodel/#src.flowmodel.Visualization.showReac","text":"Plots reaction flux Parameters: Name Type Description Default show bool Flag if figures are drawn. Defaults to True. True Returns: Type Description FigureCanvasQTAgg Canvas of reaction flux (if show=False) Source code in src\\flowmodel.py def showReac ( self , show = True ): \"\"\"Plots reaction flux Args: show (bool, optional): Flag if figures are drawn. Defaults to True. Returns: FigureCanvasQTAgg: Canvas of reaction flux (if show=False) \"\"\" if self . reacFig is None : self . reacFig = cfv . figure ( self . reacFig , show = show ) self . reac_widget = cfv . figure_widget ( self . reacFig , None ) cfv . draw_nodal_values_shaded ( self . output_data . r , self . output_data . coords , self . output_data . edof , title = \"Reaction flux\" ) cfv . colorbar ( orientation = \"horizontal\" , label = r \"Reaction flux $q$ [m$^2$/day]\" ) if show : self . wait () else : return self . reac_widget","title":"showReac()"},{"location":"flowmodel/#src.flowmodel.Visualization.wait","text":"Waits for plots to be closed Source code in src\\flowmodel.py def wait ( self ): \"\"\"Waits for plots to be closed\"\"\" cfv . show_and_wait ()","title":"wait()"},{"location":"segmenttimer/","text":"Code Reference segementtimer.py Simple Stopwatch This simple module was created as a debugging tool and for the calibration of the progressbar. It contains a single class that can create a object which can time different segments and present the data as a table. SegmentTimer Class to time segments for debugging and the progressbar Attributes: Name Type Description start float Reference starting point for each lap dic dictionary Dictionary of segment times Source code in src\\segmenttimer.py class SegmentTimer (): \"\"\"Class to time segments for debugging and the progressbar Attributes: start (float): Reference starting point for each lap dic (dictionary): Dictionary of segment times \"\"\" def __init__ ( self ): self . ref = 0. self . list = [] def start ( self ): \"\"\"Sets initial reference time\"\"\" self . ref = time . perf_counter () def seg ( self , seg ): \"\"\"Adds segment with time to list\"\"\" stop = time . perf_counter () self . list . append ([ seg , stop - self . ref ]) self . ref = stop def present ( self , nelm ): \"\"\"Presents segment results\"\"\" total = sum ( row [ 1 ] for row in self . list ) [ row . append ( row [ 1 ] / total * 100 ) for row in self . list ] table = tbl . tabulate ( self . list , headers = [ \"Segement\" , \"seconds\" , \"%\" ], numalign = \"center\" , tablefmt = \"simple\" , floatfmt = \".2f\" ) print ( f \" \\n Number of elements { nelm } \" ) print ( table + \" \\n \" ) present ( self , nelm ) Presents segment results Source code in src\\segmenttimer.py def present ( self , nelm ): \"\"\"Presents segment results\"\"\" total = sum ( row [ 1 ] for row in self . list ) [ row . append ( row [ 1 ] / total * 100 ) for row in self . list ] table = tbl . tabulate ( self . list , headers = [ \"Segement\" , \"seconds\" , \"%\" ], numalign = \"center\" , tablefmt = \"simple\" , floatfmt = \".2f\" ) print ( f \" \\n Number of elements { nelm } \" ) print ( table + \" \\n \" ) seg ( self , seg ) Adds segment with time to list Source code in src\\segmenttimer.py def seg ( self , seg ): \"\"\"Adds segment with time to list\"\"\" stop = time . perf_counter () self . list . append ([ seg , stop - self . ref ]) self . ref = stop start ( self ) Sets initial reference time Source code in src\\segmenttimer.py def start ( self ): \"\"\"Sets initial reference time\"\"\" self . ref = time . perf_counter ()","title":"Segementtimer"},{"location":"segmenttimer/#code-reference-segementtimerpy","text":"Simple Stopwatch This simple module was created as a debugging tool and for the calibration of the progressbar. It contains a single class that can create a object which can time different segments and present the data as a table.","title":"Code Reference segementtimer.py"},{"location":"segmenttimer/#src.segmenttimer.SegmentTimer","text":"Class to time segments for debugging and the progressbar Attributes: Name Type Description start float Reference starting point for each lap dic dictionary Dictionary of segment times Source code in src\\segmenttimer.py class SegmentTimer (): \"\"\"Class to time segments for debugging and the progressbar Attributes: start (float): Reference starting point for each lap dic (dictionary): Dictionary of segment times \"\"\" def __init__ ( self ): self . ref = 0. self . list = [] def start ( self ): \"\"\"Sets initial reference time\"\"\" self . ref = time . perf_counter () def seg ( self , seg ): \"\"\"Adds segment with time to list\"\"\" stop = time . perf_counter () self . list . append ([ seg , stop - self . ref ]) self . ref = stop def present ( self , nelm ): \"\"\"Presents segment results\"\"\" total = sum ( row [ 1 ] for row in self . list ) [ row . append ( row [ 1 ] / total * 100 ) for row in self . list ] table = tbl . tabulate ( self . list , headers = [ \"Segement\" , \"seconds\" , \"%\" ], numalign = \"center\" , tablefmt = \"simple\" , floatfmt = \".2f\" ) print ( f \" \\n Number of elements { nelm } \" ) print ( table + \" \\n \" )","title":"SegmentTimer"},{"location":"segmenttimer/#src.segmenttimer.SegmentTimer.present","text":"Presents segment results Source code in src\\segmenttimer.py def present ( self , nelm ): \"\"\"Presents segment results\"\"\" total = sum ( row [ 1 ] for row in self . list ) [ row . append ( row [ 1 ] / total * 100 ) for row in self . list ] table = tbl . tabulate ( self . list , headers = [ \"Segement\" , \"seconds\" , \"%\" ], numalign = \"center\" , tablefmt = \"simple\" , floatfmt = \".2f\" ) print ( f \" \\n Number of elements { nelm } \" ) print ( table + \" \\n \" )","title":"present()"},{"location":"segmenttimer/#src.segmenttimer.SegmentTimer.seg","text":"Adds segment with time to list Source code in src\\segmenttimer.py def seg ( self , seg ): \"\"\"Adds segment with time to list\"\"\" stop = time . perf_counter () self . list . append ([ seg , stop - self . ref ]) self . ref = stop","title":"seg()"},{"location":"segmenttimer/#src.segmenttimer.SegmentTimer.start","text":"Sets initial reference time Source code in src\\segmenttimer.py def start ( self ): \"\"\"Sets initial reference time\"\"\" self . ref = time . perf_counter ()","title":"start()"}]}